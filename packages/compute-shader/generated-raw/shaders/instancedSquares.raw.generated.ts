// Auto-generated by raw WGSL compute generator. DO NOT EDIT.

export const InstancedSquaresSource = `struct InstancedSquaresSettings {
  baseX: f32,
  baseY: f32,
  spacing: f32,
  scale: f32,
  gridWidth: u32,
  instanceCount: u32,
};

struct InstancedSolidInstance {
  offset: vec2f,
  scale: f32,
  rotation: f32,
};

@group(0) @binding(0) var<uniform> settings: InstancedSquaresSettings;
@group(0) @binding(1) var<storage, read_write> instanceData: array<InstancedSolidInstance>;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= settings.instanceCount) {
    return;
  }

  let row = idx / settings.gridWidth;
  let col = idx % settings.gridWidth;

  let offset = vec2f(
    settings.baseX + f32(col) * settings.spacing,
    settings.baseY + f32(row) * settings.spacing,
  );

  instanceData[idx].offset = offset;
  instanceData[idx].scale = settings.scale;
  instanceData[idx].rotation = 0.0;
}`;

export interface InstancedSquaresInstancedSquaresSettings {
  baseX: number;
  baseY: number;
  spacing: number;
  scale: number;
  gridWidth: number;
  instanceCount: number;
}

export const InstancedSquaresInstancedSquaresSettingsLayout = {
  size: 24,
  align: 4,
  members: [
  { name: 'baseX', offset: 0, size: 4, slot: 1 },
  { name: 'baseY', offset: 4, size: 4, slot: 1 },
  { name: 'spacing', offset: 8, size: 4, slot: 1 },
  { name: 'scale', offset: 12, size: 4, slot: 1 },
  { name: 'gridWidth', offset: 16, size: 4, slot: 1 },
  { name: 'instanceCount', offset: 20, size: 4, slot: 1 }
  ] as const,
} as const;

export function packInstancedSquaresInstancedSquaresSettings(target: Float32Array, floatOffset: number, value: InstancedSquaresInstancedSquaresSettings): void {
  const uintView = new Uint32Array(target.buffer);
  {
    const base = floatOffset + 0;
    const raw = value.baseX;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 1;
    const raw = value.baseY;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 2;
    const raw = value.spacing;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 3;
    const raw = value.scale;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 4;
    const raw = value.gridWidth;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
  {
    const base = floatOffset + 5;
    const raw = value.instanceCount;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
}

export interface InstancedSquaresInstancedSolidInstance {
  offset: Float32Array | readonly number[];
  scale: number;
  rotation: number;
}

export const InstancedSquaresInstancedSolidInstanceLayout = {
  size: 16,
  align: 8,
  members: [
  { name: 'offset', offset: 0, size: 8, slot: 2 },
  { name: 'scale', offset: 8, size: 4, slot: 1 },
  { name: 'rotation', offset: 12, size: 4, slot: 1 }
  ] as const,
} as const;

export function packInstancedSquaresInstancedSolidInstance(target: Float32Array, floatOffset: number, value: InstancedSquaresInstancedSolidInstance): void {
  {
    const base = floatOffset + 0;
    const offsetSource = value.offset as any;
    for (let i = 0; i < 2; i++) {
      const component = offsetSource?.[i];
      target[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
  {
    const base = floatOffset + 2;
    const raw = value.scale;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 3;
    const raw = value.rotation;
    target[base] = raw !== undefined ? Number(raw) : 0;
  }
}

const uniformLayout_settings = [
  { name: 'baseX', slot: 1 },
  { name: 'baseY', slot: 1 },
  { name: 'spacing', slot: 1 },
  { name: 'scale', slot: 1 },
  { name: 'gridWidth', slot: 1 },
  { name: 'instanceCount', slot: 1 }
] as const;

export interface SettingsUniforms {
  baseX: number;
  baseY: number;
  spacing: number;
  scale: number;
  gridWidth: number;
  instanceCount: number;
}

export interface SettingsUniformState {
  device: GPUDevice;
  buffer: GPUBuffer;
  data: ArrayBuffer;
  floatView: Float32Array;
  uniforms: SettingsUniforms;
}

export function createUniformBuffer_settings(device: GPUDevice, initial?: Partial<SettingsUniforms>): SettingsUniformState {
  const data = new ArrayBuffer(32);
  const floatView = new Float32Array(data);
  let uniforms: SettingsUniforms = {
    baseX: 0,
    baseY: 0,
    spacing: 0,
    scale: 0,
    gridWidth: 0,
    instanceCount: 0,
  };
  if (initial) {
    uniforms = { ...uniforms, ...initial };
  }
  packInstancedSquaresInstancedSquaresSettings(floatView, 0, uniforms);
  const buffer = device.createBuffer({ size: data.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(buffer, 0, data);
  return { device, buffer, data, floatView, uniforms };
}

export function updateUniformBuffer_settings(state: SettingsUniformState, updates: Partial<SettingsUniforms>): void {
  if (!updates) {
    return;
  }
  state.uniforms = { ...state.uniforms, ...updates };
  packInstancedSquaresInstancedSquaresSettings(state.floatView, 0, state.uniforms);
  state.device.queue.writeBuffer(state.buffer, 0, state.data);
}

export interface InstanceDataStorageState {
  device: GPUDevice;
  buffer: GPUBuffer;
  data: Float32Array;
  capacity: number;
  floatsPerElement: number;
}

export function createStorageBuffer_instanceData(device: GPUDevice, capacity: number, options?: { initial?: InstancedSquaresInstancedSolidInstance[]; usage?: GPUBufferUsageFlags; }): InstanceDataStorageState {
  const byteStride = 16;
  const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;
  const totalFloats = floatsPerElement * capacity;
  const data = new Float32Array(totalFloats);
  const usage = options?.usage ?? (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
  const buffer = device.createBuffer({ size: byteStride * capacity, usage });
  if (options?.initial) {
    options.initial.slice(0, capacity).forEach((value, index) => {
      packInstancedSquaresInstancedSolidInstance(data, index * floatsPerElement, value);
    });
    const dataView = data.buffer instanceof ArrayBuffer
      ? new Float32Array(data.buffer, data.byteOffset, data.length)
      : new Float32Array(data);
    device.queue.writeBuffer(buffer, 0, dataView);
  }
  return { device, buffer, data, capacity, floatsPerElement };
}

export function writeStorageValue_instanceData(state: InstanceDataStorageState, index: number, value: InstancedSquaresInstancedSolidInstance): void {
  const offset = index * state.floatsPerElement;
  packInstancedSquaresInstancedSolidInstance(state.data, offset, value);
}

export function updateStorageBuffer_instanceData(state: InstanceDataStorageState): void {
  const dataView = state.data.buffer instanceof ArrayBuffer
    ? new Float32Array(state.data.buffer, state.data.byteOffset, state.data.length)
    : new Float32Array(state.data);
  state.device.queue.writeBuffer(state.buffer, 0, dataView);
}

const bindingLayout = {
    settings: { group: 0, binding: 0 },
    instanceData: { group: 0, binding: 1 }
};

export interface ShaderBindings {
    settings: SettingsUniformState;
    instanceData: GPUBuffer;
}

export interface ShaderState {
  device: GPUDevice;
  pipeline: GPUComputePipeline;
  bindGroupLayouts: GPUBindGroupLayout[];
  bindGroups: GPUBindGroup[];
  bindings: ShaderBindings;
}

function buildBindGroups(device: GPUDevice, bindGroupLayouts: GPUBindGroupLayout[], bindings: ShaderBindings): GPUBindGroup[] {
  const groups: GPUBindGroup[] = [];
  groups[0] = device.createBindGroup({
    layout: bindGroupLayouts[0],
    entries: [
      { binding: 0, resource: { buffer: bindings.settings.buffer } },
      { binding: 1, resource: { buffer: bindings.instanceData } },
    ],
  });
  for (let i = 0; i < bindGroupLayouts.length; i++) {
    if (!groups[i]) {
      groups[i] = device.createBindGroup({ layout: bindGroupLayouts[i], entries: [] });
    }
  }
  return groups;
}

export function createShader(device: GPUDevice, bindings: ShaderBindings, options?: { entryPoint?: string; source?: string; label?: string; }): ShaderState {
  const bindGroupLayouts: GPUBindGroupLayout[] = [];
  bindGroupLayouts[0] = device.createBindGroupLayout({ entries: [
    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
  ] });
  for (let i = 0; i <= 0; i++) {
    if (!bindGroupLayouts[i]) {
      bindGroupLayouts[i] = device.createBindGroupLayout({ entries: [] });
    }
  }
  const label = options?.label ?? 'instancedSquares';
  const shaderModule = device.createShaderModule({ label, code: options?.source ?? InstancedSquaresSource });
  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts });
  const pipeline = device.createComputePipeline({ label, layout: pipelineLayout, compute: { module: shaderModule, entryPoint: options?.entryPoint ?? 'main' } });
  const bindGroups = buildBindGroups(device, bindGroupLayouts, bindings);
  return { device, pipeline, bindGroupLayouts, bindGroups, bindings };
}

export function updateBindings(state: ShaderState, updates: Partial<ShaderBindings>): void {
  let dirty = false;
  if (updates.settings !== undefined) {
    state.bindings.settings = updates.settings!;
    dirty = true;
  }
  if (updates.instanceData !== undefined) {
    state.bindings.instanceData = updates.instanceData!;
    dirty = true;
  }
  if (!dirty) {
    return;
  }
  state.bindGroups = buildBindGroups(state.device, state.bindGroupLayouts, state.bindings);
}

export const createUniformBuffer = createUniformBuffer_settings;
export const updateUniformBuffer = updateUniformBuffer_settings;