import { ArgumentInfo, StructInfo, WgslReflect } from 'wgsl_reflect';
import { toPascalCase, escapeTemplateLiteral } from '../../codegen-common/utils.ts';

export const RAW_SUFFIX = '.strokeMaterial.wgsl';
export const OUTPUT_SUFFIX = '.strokeMaterial.raw.generated.ts';

const HEADER_COMMENT = '// Auto-generated by power2d raw stroke material generator. DO NOT EDIT.';
const SHAPE_TRANSLATE_UNIFORM = 'power2d_shapeTranslate';
const SHAPE_ROTATION_UNIFORM = 'power2d_shapeRotation';
const SHAPE_SCALE_UNIFORM = 'power2d_shapeScale';
const STROKE_THICKNESS_UNIFORM = 'power2d_strokeThickness';

interface TextureParam {
  textureName: string;
  samplerName: string;
}

interface TypeMapping {
  tsType: string;
  slotCount: number;
  valueLength: number;
  componentType: 'f32' | 'i32' | 'u32' | 'bool';
  isVector: boolean;
  defaultExpression: string;
}

const TYPE_MAP: Record<string, TypeMapping> = {
  f32: { tsType: 'number', slotCount: 1, valueLength: 1, componentType: 'f32', isVector: false, defaultExpression: '0' },
  i32: { tsType: 'number', slotCount: 1, valueLength: 1, componentType: 'i32', isVector: false, defaultExpression: '0' },
  u32: { tsType: 'number', slotCount: 1, valueLength: 1, componentType: 'u32', isVector: false, defaultExpression: '0' },
  bool: { tsType: 'boolean', slotCount: 1, valueLength: 1, componentType: 'bool', isVector: false, defaultExpression: 'false' },
  vec2f: { tsType: 'readonly [number, number]', slotCount: 2, valueLength: 2, componentType: 'f32', isVector: true, defaultExpression: '[0, 0]' },
  vec3f: { tsType: 'readonly [number, number, number]', slotCount: 4, valueLength: 3, componentType: 'f32', isVector: true, defaultExpression: '[0, 0, 0]' },
  vec4f: { tsType: 'readonly [number, number, number, number]', slotCount: 4, valueLength: 4, componentType: 'f32', isVector: true, defaultExpression: '[0, 0, 0, 0]' },
  mat4x4f: { tsType: 'Float32Array | readonly number[]', slotCount: 16, valueLength: 16, componentType: 'f32', isVector: true, defaultExpression: 'new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])' },
};

function mappingFor(typeName: string): TypeMapping | null {
  return TYPE_MAP[typeName] ?? null;
}

function validateType(argument: ArgumentInfo, expected: string, label: string): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== expected) {
    throw new Error(`${label} must be ${expected}. Received ${argument.name}: ${typeName}`);
  }
}

function parseTextureParams(args: ArgumentInfo[], startIndex: number, functionName: string): TextureParam[] {
  const params: TextureParam[] = [];
  const seenTextures = new Set<string>();

  for (let index = startIndex; index < args.length; index += 2) {
    const textureArg = args[index];
    const samplerArg = args[index + 1];

    if (!textureArg || !samplerArg) {
      throw new Error(`Texture parameters in ${functionName} must be provided in texture/sampler pairs.`);
    }

    const textureType = textureArg.type.getTypeName();
    if (textureType !== 'texture_2d<f32>') {
      throw new Error(`Texture argument must be texture_2d<f32>. Received ${textureArg.name}: ${textureType}`);
    }

    const samplerType = samplerArg.type.getTypeName();
    if (samplerType !== 'sampler') {
      throw new Error(`Expected sampler after texture ${textureArg.name}, but got ${samplerArg.name}: ${samplerType}. Texture parameters must be provided in texture/sampler pairs.`);
    }

    if (seenTextures.has(textureArg.name)) {
      throw new Error(`Duplicate texture parameter ${textureArg.name} detected.`);
    }
    seenTextures.add(textureArg.name);

    params.push({
      textureName: textureArg.name,
      samplerName: samplerArg.name,
    });
  }

  return params;
}

function buildVertexSource(options: {
  shaderCode: string;
  uniformStructName: string;
}): string {
  const { shaderCode, uniformStructName } = options;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push(`@group(0) @binding(0) var<uniform> uniforms: ${uniformStructName};`);
  lines.push('struct Power2DBuiltins {');
  lines.push(`  ${SHAPE_TRANSLATE_UNIFORM}: vec2f,`);
  lines.push(`  ${SHAPE_ROTATION_UNIFORM}: f32,`);
  lines.push('  _pad0: f32,');
  lines.push(`  ${SHAPE_SCALE_UNIFORM}: vec2f,`);
  lines.push('  power2d_canvasWidth: f32,');
  lines.push('  power2d_canvasHeight: f32,');
  lines.push(`  ${STROKE_THICKNESS_UNIFORM}: f32,`);
  lines.push('  _pad1: f32,');
  lines.push('};');
  lines.push('@group(0) @binding(1) var<uniform> power2d: Power2DBuiltins;');
  lines.push('');
  lines.push(shaderCode.trimEnd());
  lines.push('');
  lines.push('struct VertexInput {');
  lines.push('  @location(0) position: vec2f,');
  lines.push('  @location(1) uv: vec2f,');
  lines.push('  @location(2) strokeNormal: vec2f,');
  lines.push('  @location(3) strokeSide: f32,');
  lines.push('  @location(4) strokeArcLength: f32,');
  lines.push('  @location(5) strokeNormalizedArc: f32,');
  lines.push('  @location(6) strokeMiterFactor: f32,');
  lines.push('};');
  lines.push('struct VertexOutput {');
  lines.push('  @builtin(position) position: vec4f,');
  lines.push('  @location(0) vUV: vec2f,');
  lines.push('  @location(1) vStrokeNormal: vec2f,');
  lines.push('  @location(2) vStrokeSide: f32,');
  lines.push('  @location(3) vStrokeArcLength: f32,');
  lines.push('  @location(4) vStrokeNormalizedArc: f32,');
  lines.push('  @location(5) vStrokeMiterFactor: f32,');
  lines.push('};');
  lines.push('');
  lines.push('fn power2d_applyShapeTransform(pixel: vec2f) -> vec2f {');
  lines.push(`  let scaled = pixel * power2d.${SHAPE_SCALE_UNIFORM};`);
  lines.push(`  let s = sin(power2d.${SHAPE_ROTATION_UNIFORM});`);
  lines.push(`  let c = cos(power2d.${SHAPE_ROTATION_UNIFORM});`);
  lines.push('  let rotated = vec2f(');
  lines.push('    scaled.x * c - scaled.y * s,');
  lines.push('    scaled.x * s + scaled.y * c,');
  lines.push('  );');
  lines.push(`  return rotated + power2d.${SHAPE_TRANSLATE_UNIFORM};`);
  lines.push('}');
  lines.push('');
  lines.push('fn power2d_pixelToNDC(pixel: vec2f) -> vec4f {');
  lines.push('  let ndcX = (pixel.x / power2d.power2d_canvasWidth) * 2.0 - 1.0;');
  lines.push('  let ndcY = -((pixel.y / power2d.power2d_canvasHeight) * 2.0 - 1.0);');
  lines.push('  return vec4f(ndcX, ndcY, 0.0, 1.0);');
  lines.push('}');
  lines.push('');
  lines.push('@vertex');
  lines.push('fn main(input: VertexInput) -> VertexOutput {');
  lines.push('  var out: VertexOutput;');
  lines.push('  let pixelPos = input.position;');
  lines.push('  let uv = input.uv;');
  lines.push('  let normal = input.strokeNormal;');
  lines.push('  let side = input.strokeSide;');
  lines.push('  let arcLength = input.strokeArcLength;');
  lines.push('  let normalizedArc = input.strokeNormalizedArc;');
  lines.push('  let miterFactor = input.strokeMiterFactor;');
  lines.push(`  let adjustedPixelPos = vertShader(pixelPos, uv, normal, side, arcLength, normalizedArc, miterFactor, uniforms);`);
  lines.push('  let transformedPixelPos = power2d_applyShapeTransform(adjustedPixelPos);');
  lines.push('  out.position = power2d_pixelToNDC(transformedPixelPos);');
  lines.push('  out.vUV = uv;');
  lines.push('  out.vStrokeNormal = normal;');
  lines.push('  out.vStrokeSide = side;');
  lines.push('  out.vStrokeArcLength = arcLength;');
  lines.push('  out.vStrokeNormalizedArc = normalizedArc;');
  lines.push('  out.vStrokeMiterFactor = miterFactor;');
  lines.push('  return out;');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function buildFragmentSource(options: {
  shaderCode: string;
  uniformStructName: string;
  textureParams: TextureParam[];
}): string {
  const { shaderCode, uniformStructName, textureParams } = options;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push(`@group(0) @binding(0) var<uniform> uniforms: ${uniformStructName};`);
  lines.push('struct Power2DBuiltins {');
  lines.push(`  ${SHAPE_TRANSLATE_UNIFORM}: vec2f,`);
  lines.push(`  ${SHAPE_ROTATION_UNIFORM}: f32,`);
  lines.push('  _pad0: f32,');
  lines.push(`  ${SHAPE_SCALE_UNIFORM}: vec2f,`);
  lines.push('  power2d_canvasWidth: f32,');
  lines.push('  power2d_canvasHeight: f32,');
  lines.push(`  ${STROKE_THICKNESS_UNIFORM}: f32,`);
  lines.push('  _pad1: f32,');
  lines.push('};');
  lines.push('@group(0) @binding(1) var<uniform> power2d: Power2DBuiltins;');
  let bindingIndex = 2;
  for (const param of textureParams) {
    lines.push(`@group(0) @binding(${bindingIndex}) var ${param.textureName}: texture_2d<f32>;`);
    bindingIndex += 1;
    lines.push(`@group(0) @binding(${bindingIndex}) var ${param.samplerName}: sampler;`);
    bindingIndex += 1;
  }
  lines.push('');
  lines.push(shaderCode.trimEnd());
  lines.push('');
  lines.push('struct FragmentInput {');
  lines.push('  @location(0) vUV: vec2f,');
  lines.push('  @location(1) vStrokeNormal: vec2f,');
  lines.push('  @location(2) vStrokeSide: f32,');
  lines.push('  @location(3) vStrokeArcLength: f32,');
  lines.push('  @location(4) vStrokeNormalizedArc: f32,');
  lines.push('  @location(5) vStrokeMiterFactor: f32,');
  lines.push('};');
  lines.push('');
  lines.push('@fragment');
  lines.push('fn main(input: FragmentInput) -> @location(0) vec4f {');
  lines.push('  let uv = input.vUV;');
  lines.push('  let normal = input.vStrokeNormal;');
  lines.push('  let side = input.vStrokeSide;');
  lines.push('  let arcLength = input.vStrokeArcLength;');
  lines.push('  let normalizedArc = input.vStrokeNormalizedArc;');
  lines.push('  let miterFactor = input.vStrokeMiterFactor;');
  const args: string[] = ['uv', 'normal', 'side', 'arcLength', 'normalizedArc', 'miterFactor', 'uniforms'];
  for (const param of textureParams) {
    args.push(param.textureName, param.samplerName);
  }
  lines.push(`  return fragShader(${args.join(', ')});`);
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function buildUniformInterface(struct: StructInfo): { interfaceLines: string[]; defaultsLines: string[] } {
  const interfaceLines: string[] = [];
  const defaultsLines: string[] = [];
  interfaceLines.push(`export interface ${struct.name} {`);
  defaultsLines.push(`export const ${struct.name}Defaults: ${struct.name} = {`);
  for (const member of struct.members) {
    if (member.type.isStruct) {
      throw new Error(`Uniform field ${member.name} uses unsupported struct type ${member.type.getTypeName()}.`);
    }
    if (member.type.isArray) {
      const elementType = member.format?.getTypeName();
      if (!elementType) {
        throw new Error(`Uniform array field ${member.name} element type could not be determined.`);
      }
      const mapping = mappingFor(elementType);
      if (!mapping) {
        throw new Error(`Uniform array field ${member.name} uses unsupported element type ${elementType}.`);
      }
      interfaceLines.push(`  ${member.name}: readonly ${mapping.tsType}[];`);
      const count = member.count ?? 0;
      defaultsLines.push(`  ${member.name}: Array.from({ length: ${count} }, () => ${mapping.defaultExpression}),`);
      continue;
    }
    const typeName = member.type.getTypeName();
    const mapping = mappingFor(typeName);
    if (!mapping) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    interfaceLines.push(`  ${member.name}: ${mapping.tsType};`);
    defaultsLines.push(`  ${member.name}: ${mapping.defaultExpression},`);
  }
  interfaceLines.push('}');
  defaultsLines.push('};');
  return { interfaceLines, defaultsLines };
}

function buildUniformPacker(struct: StructInfo): { packLines: string[]; needsInt: boolean; needsUint: boolean } {
  const packLines: string[] = [];
  let needsInt = false;
  let needsUint = false;

  for (const member of struct.members) {
    const offsetSlots = member.offset / 4;
    if (member.type.isArray) {
      const elementType = member.format?.getTypeName();
      if (!elementType) {
        throw new Error(`Uniform array field ${member.name} element type could not be determined.`);
      }
      const mapping = mappingFor(elementType);
      if (!mapping) {
        throw new Error(`Uniform array field ${member.name} uses unsupported element type ${elementType}.`);
      }
      if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
        needsInt = true;
      }
      if (mapping.componentType === 'u32') {
        needsUint = true;
      }
      const count = member.count ?? 0;
      const strideSlots = member.size / 4 / Math.max(1, count);
      packLines.push(`  {`);
      packLines.push(`    const values = value.${member.name} ?? [];`);
      packLines.push(`    for (let i = 0; i < ${count}; i++) {`);
      packLines.push(`      const base = floatOffset + ${offsetSlots} + i * ${strideSlots};`);
      if (mapping.isVector) {
        packLines.push(`      const source = values[i] as any;`);
        packLines.push(`      for (let c = 0; c < ${mapping.valueLength}; c++) {`);
        packLines.push(`        const component = source?.[c];`);
        switch (mapping.componentType) {
          case 'f32':
            packLines.push('        floatView[base + c] = component !== undefined ? Number(component) : 0;');
            break;
          case 'i32':
            packLines.push('        intView[base + c] = component !== undefined ? Math.trunc(component as number) : 0;');
            break;
          case 'u32':
            packLines.push('        uintView[base + c] = component !== undefined ? Math.trunc(component as number) >>> 0 : 0;');
            break;
          case 'bool':
            packLines.push('        intView[base + c] = component ? 1 : 0;');
            break;
        }
        packLines.push('      }');
        if (strideSlots > mapping.valueLength) {
          packLines.push(`      for (let c = ${mapping.valueLength}; c < ${strideSlots}; c++) {`);
          if (mapping.componentType === 'u32') {
            packLines.push('        uintView[base + c] = 0;');
          } else if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
            packLines.push('        intView[base + c] = 0;');
          } else {
            packLines.push('        floatView[base + c] = 0;');
          }
          packLines.push('      }');
        }
      } else {
        packLines.push(`      const component = values[i];`);
        switch (mapping.componentType) {
          case 'f32':
            packLines.push('      floatView[base] = component !== undefined ? Number(component) : 0;');
            break;
          case 'i32':
            packLines.push('      intView[base] = component !== undefined ? Math.trunc(component as number) : 0;');
            break;
          case 'u32':
            packLines.push('      uintView[base] = component !== undefined ? Math.trunc(component as number) >>> 0 : 0;');
            break;
          case 'bool':
            packLines.push('      intView[base] = component ? 1 : 0;');
            break;
        }
        if (strideSlots > 1) {
          packLines.push('      for (let c = 1; c < ' + strideSlots + '; c++) {');
          if (mapping.componentType === 'u32') {
            packLines.push('        uintView[base + c] = 0;');
          } else if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
            packLines.push('        intView[base + c] = 0;');
          } else {
            packLines.push('        floatView[base + c] = 0;');
          }
          packLines.push('      }');
        }
      }
      packLines.push('    }');
      packLines.push('  }');
      continue;
    }

    const typeName = member.type.getTypeName();
    const mapping = mappingFor(typeName);
    if (!mapping) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
      needsInt = true;
    }
    if (mapping.componentType === 'u32') {
      needsUint = true;
    }
    packLines.push('  {');
    packLines.push(`    const base = floatOffset + ${offsetSlots};`);
    if (!mapping.isVector) {
      switch (mapping.componentType) {
        case 'f32':
          packLines.push(`    const raw = value.${member.name};`);
          packLines.push('    floatView[base] = raw !== undefined ? Number(raw) : 0;');
          break;
        case 'i32':
          packLines.push(`    const raw = value.${member.name};`);
          packLines.push('    intView[base] = raw !== undefined ? Math.trunc(raw as number) : 0;');
          break;
        case 'u32':
          packLines.push(`    const raw = value.${member.name};`);
          packLines.push('    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;');
          break;
        case 'bool':
          packLines.push(`    const raw = value.${member.name};`);
          packLines.push('    intView[base] = raw ? 1 : 0;');
          break;
      }
    } else {
      const sourceVar = `${member.name}Source`;
      packLines.push(`    const ${sourceVar} = value.${member.name} as any;`);
      packLines.push(`    for (let i = 0; i < ${mapping.valueLength}; i++) {`);
      packLines.push(`      const component = ${sourceVar}?.[i];`);
      switch (mapping.componentType) {
        case 'f32':
          packLines.push('      floatView[base + i] = component !== undefined ? Number(component) : 0;');
          break;
        case 'i32':
          packLines.push('      intView[base + i] = component !== undefined ? Math.trunc(component as number) : 0;');
          break;
        case 'u32':
          packLines.push('      uintView[base + i] = component !== undefined ? Math.trunc(component as number) >>> 0 : 0;');
          break;
        case 'bool':
          packLines.push('      intView[base + i] = component ? 1 : 0;');
          break;
      }
      packLines.push('    }');
      if (mapping.slotCount > mapping.valueLength) {
        packLines.push(`    for (let i = ${mapping.valueLength}; i < ${mapping.slotCount}; i++) {`);
        if (mapping.componentType === 'u32') {
          packLines.push('      uintView[base + i] = 0;');
        } else if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
          packLines.push('      intView[base + i] = 0;');
        } else {
          packLines.push('      floatView[base + i] = 0;');
        }
        packLines.push('    }');
      }
    }
    packLines.push('  }');
  }

  return { packLines, needsInt, needsUint };
}

export interface GenerateMaterialTypesSourceResult {
  typesSource: string;
}

export function generateStrokeMaterialTypesSource(shaderCode: string, shaderBaseName: string): GenerateMaterialTypesSourceResult {
  const shaderPrefix = toPascalCase(shaderBaseName);

  const reflect = new WgslReflect(shaderCode);

  const vertFn = reflect.functions.find((fn) => fn.name === 'vertShader' && !fn.stage);
  const fragFn = reflect.functions.find((fn) => fn.name === 'fragShader' && !fn.stage);
  if (!vertFn) {
    throw new Error('Missing vertShader function.');
  }
  if (!fragFn) {
    throw new Error('Missing fragShader function.');
  }

  if (vertFn.arguments.length !== 8) {
    throw new Error('Stroke vertShader must declare 8 arguments (position, uv, normal, side, arcLength, normalizedArc, miterFactor, uniforms).');
  }

  validateType(vertFn.arguments[0], 'vec2f', 'vertShader position argument');
  validateType(vertFn.arguments[1], 'vec2f', 'vertShader uv argument');
  validateType(vertFn.arguments[2], 'vec2f', 'vertShader normal argument');
  validateType(vertFn.arguments[3], 'f32', 'vertShader side argument');
  validateType(vertFn.arguments[4], 'f32', 'vertShader arcLength argument');
  validateType(vertFn.arguments[5], 'f32', 'vertShader normalizedArc argument');
  validateType(vertFn.arguments[6], 'f32', 'vertShader miterFactor argument');

  const uniformArg = vertFn.arguments[7];
  const uniformStruct = reflect.structs.find((entry) => entry.name === uniformArg.type.getTypeName());
  if (!uniformStruct) {
    throw new Error(`Uniform struct ${uniformArg.type.getTypeName()} not found.`);
  }

  if (fragFn.arguments.length < 7) {
    throw new Error('fragShader must declare at least 7 arguments (uv, normal, side, arcLength, normalizedArc, miterFactor, uniforms).');
  }

  validateType(fragFn.arguments[0], 'vec2f', 'fragShader uv argument');
  const fragUniformArg = fragFn.arguments[6];
  if (fragUniformArg.type.getTypeName() !== uniformStruct.name) {
    throw new Error(`fragShader uniforms must use struct ${uniformStruct.name}.`);
  }

  const textureParams = parseTextureParams(fragFn.arguments, 7, 'fragShader');

  const vertexSource = buildVertexSource({
    shaderCode,
    uniformStructName: uniformStruct.name,
  });

  const fragmentSource = buildFragmentSource({
    shaderCode,
    uniformStructName: uniformStruct.name,
    textureParams,
  });

  const { interfaceLines, defaultsLines } = buildUniformInterface(uniformStruct);
  const { packLines, needsInt, needsUint } = buildUniformPacker(uniformStruct);

  const textureNames = textureParams.map((param) => param.textureName);
  const textureNameUnion = textureNames.length ? textureNames.map((name) => `'${name}'`).join(' | ') : 'never';
  const textureNamesLiteral = textureNames.length ? `[${textureNames.map((name) => `'${name}'`).join(', ')}] as const` : '[] as const';

  const materialInterfaceName = `${shaderPrefix}StrokeMaterialDef`;
  const materialInstanceName = `${shaderPrefix}StrokeMaterialInstance`;
  const materialConstName = `${shaderPrefix}StrokeMaterial`;

  const attributeOrder = ['position', 'uv', 'strokeNormal', 'strokeSide', 'strokeArcLength', 'strokeNormalizedArc', 'strokeMiterFactor'];

  const bindingBase = 2;
  const textureBindingEntries = textureParams.map((param, index) => {
    const textureBinding = bindingBase + index * 2;
    const samplerBinding = textureBinding + 1;
    return { param, textureBinding, samplerBinding };
  });

  const layoutSize = uniformStruct.size;
  const tsLines: string[] = [];
  tsLines.push(HEADER_COMMENT);
  tsLines.push(`import type { MaterialDef, MaterialInstance } from '@avtools/power2d/raw';`);
  tsLines.push('');
  tsLines.push(`export const ${shaderPrefix}VertexSource = ${escapeTemplateLiteral(vertexSource)};`);
  tsLines.push(`export const ${shaderPrefix}FragmentSource = ${escapeTemplateLiteral(fragmentSource)};`);
  tsLines.push('');
  tsLines.push(...interfaceLines);
  tsLines.push('');
  tsLines.push(...defaultsLines);
  tsLines.push('');
  tsLines.push(`export type ${shaderPrefix}TextureName = ${textureNameUnion};`);
  tsLines.push(`export const ${shaderPrefix}TextureNames = ${textureNamesLiteral};`);
  tsLines.push('');

  tsLines.push(`const ${uniformStruct.name}LayoutSize = ${layoutSize};`);
  tsLines.push('');
  tsLines.push(`function pack${uniformStruct.name}(floatView: Float32Array, intView: Int32Array, uintView: Uint32Array, floatOffset: number, value: ${uniformStruct.name}): void {`);
  tsLines.push(...packLines.length ? packLines : ['  // No uniforms to pack']);
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export interface ${materialInstanceName} extends MaterialInstance<${uniformStruct.name}, ${shaderPrefix}TextureName> {}`);
  tsLines.push('');
  tsLines.push(`export function create${shaderPrefix}Material(device: GPUDevice, format: GPUTextureFormat, name = '${shaderPrefix}StrokeMaterial'): ${materialInstanceName} {`);
  tsLines.push('  const uniformData = new ArrayBuffer(' + layoutSize + ');');
  tsLines.push('  const uniformFloats = new Float32Array(uniformData);');
  tsLines.push('  const uniformInts = new Int32Array(uniformData);');
  tsLines.push('  const uniformUints = new Uint32Array(uniformData);');
  tsLines.push(`  let currentUniforms: ${uniformStruct.name} = { ...${uniformStruct.name}Defaults };`);
  tsLines.push('  pack' + uniformStruct.name + '(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);');
  tsLines.push('  const uniformBuffer = device.createBuffer({ size: uniformData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });');
  tsLines.push('  device.queue.writeBuffer(uniformBuffer, 0, uniformData);');
  tsLines.push('');
  tsLines.push('  const builtinsData = new Float32Array([');
  tsLines.push('    0, 0, 0, 0,');
  tsLines.push('    1, 1, 0, 0,');
  tsLines.push('    1, 0,');
  tsLines.push('  ]);');
  tsLines.push('  const builtinsBuffer = device.createBuffer({ size: builtinsData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });');
  tsLines.push('  device.queue.writeBuffer(builtinsBuffer, 0, builtinsData);');
  tsLines.push('');

  tsLines.push('  const bindGroupLayout = device.createBindGroupLayout({ entries: [');
  tsLines.push('    { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },');
  tsLines.push('    { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },');
  for (const entry of textureBindingEntries) {
    tsLines.push(`    { binding: ${entry.textureBinding}, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },`);
    tsLines.push(`    { binding: ${entry.samplerBinding}, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },`);
  }
  tsLines.push('  ] });');
  tsLines.push('');
  tsLines.push('  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });');
  tsLines.push('  const vertexModule = device.createShaderModule({ code: ' + `${shaderPrefix}VertexSource` + ' });');
  tsLines.push('  const fragmentModule = device.createShaderModule({ code: ' + `${shaderPrefix}FragmentSource` + ' });');
  tsLines.push('');
  tsLines.push('  const pipeline = device.createRenderPipeline({');
  tsLines.push('    layout: pipelineLayout,');
  tsLines.push('    vertex: {');
  tsLines.push('      module: vertexModule,');
  tsLines.push("      entryPoint: 'main',");
  tsLines.push('      buffers: [');
  tsLines.push('        { arrayStride: 8, attributes: [{ shaderLocation: 0, offset: 0, format: "float32x2" }] },');
  tsLines.push('        { arrayStride: 8, attributes: [{ shaderLocation: 1, offset: 0, format: "float32x2" }] },');
  tsLines.push('        { arrayStride: 8, attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }] },');
  tsLines.push('        { arrayStride: 4, attributes: [{ shaderLocation: 3, offset: 0, format: "float32" }] },');
  tsLines.push('        { arrayStride: 4, attributes: [{ shaderLocation: 4, offset: 0, format: "float32" }] },');
  tsLines.push('        { arrayStride: 4, attributes: [{ shaderLocation: 5, offset: 0, format: "float32" }] },');
  tsLines.push('        { arrayStride: 4, attributes: [{ shaderLocation: 6, offset: 0, format: "float32" }] },');
  tsLines.push('      ],');
  tsLines.push('    },');
  tsLines.push('    fragment: {');
  tsLines.push('      module: fragmentModule,');
  tsLines.push("      entryPoint: 'main',");
  tsLines.push('      targets: [{ format }],');
  tsLines.push('    },');
  tsLines.push("    primitive: { topology: 'triangle-list', cullMode: 'none' },");
  tsLines.push('  });');
  tsLines.push('');

  tsLines.push('  const samplers: Record<string, GPUSampler> = {};');
  tsLines.push('  const textureViews: Record<string, GPUTextureView> = {};');
  if (textureBindingEntries.length > 0) {
    tsLines.push('  for (const name of ' + `${shaderPrefix}TextureNames` + ') {');
    tsLines.push('    samplers[name] = device.createSampler({ magFilter: "linear", minFilter: "linear" });');
    tsLines.push('    const placeholder = device.createTexture({ size: { width: 1, height: 1 }, format, usage: GPUTextureUsage.TEXTURE_BINDING });');
    tsLines.push('    textureViews[name] = placeholder.createView();');
    tsLines.push('  }');
  }
  tsLines.push('');

  tsLines.push('  let bindGroup = device.createBindGroup({');
  tsLines.push('    layout: bindGroupLayout,');
  tsLines.push('    entries: [');
  tsLines.push('      { binding: 0, resource: { buffer: uniformBuffer } },');
  tsLines.push('      { binding: 1, resource: { buffer: builtinsBuffer } },');
  for (const entry of textureBindingEntries) {
    tsLines.push(`      { binding: ${entry.textureBinding}, resource: textureViews['${entry.param.textureName}'] },`);
    tsLines.push(`      { binding: ${entry.samplerBinding}, resource: samplers['${entry.param.textureName}'] },`);
  }
  tsLines.push('    ],');
  tsLines.push('  });');
  tsLines.push('');

  tsLines.push('  const rebuildBindGroup = () => {');
  tsLines.push('    bindGroup = device.createBindGroup({');
  tsLines.push('      layout: bindGroupLayout,');
  tsLines.push('      entries: [');
  tsLines.push('        { binding: 0, resource: { buffer: uniformBuffer } },');
  tsLines.push('        { binding: 1, resource: { buffer: builtinsBuffer } },');
  for (const entry of textureBindingEntries) {
    tsLines.push(`        { binding: ${entry.textureBinding}, resource: textureViews['${entry.param.textureName}'] },`);
    tsLines.push(`        { binding: ${entry.samplerBinding}, resource: samplers['${entry.param.textureName}'] },`);
  }
  tsLines.push('      ],');
  tsLines.push('    });');
  tsLines.push('  };');
  tsLines.push('');

  tsLines.push('  const instance: ' + materialInstanceName + ' = {');
  tsLines.push('    pipeline,');
  tsLines.push('    get bindGroup() { return bindGroup; },');
  tsLines.push(`    attributeOrder: ${JSON.stringify(attributeOrder)},`);
  tsLines.push('    setUniforms: (updates) => {');
  tsLines.push('      currentUniforms = { ...currentUniforms, ...updates };');
  tsLines.push(`      pack${uniformStruct.name}(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);`);
  tsLines.push('      device.queue.writeBuffer(uniformBuffer, 0, uniformData);');
  tsLines.push('    },');
  tsLines.push('    setBuiltins: (updates) => {');
  tsLines.push('      if (updates.power2d_shapeTranslate) { builtinsData[0] = updates.power2d_shapeTranslate[0]; builtinsData[1] = updates.power2d_shapeTranslate[1]; }');
  tsLines.push('      if (updates.power2d_shapeRotation !== undefined) { builtinsData[2] = updates.power2d_shapeRotation; }');
  tsLines.push('      if (updates.power2d_shapeScale) { builtinsData[4] = updates.power2d_shapeScale[0]; builtinsData[5] = updates.power2d_shapeScale[1]; }');
  tsLines.push('      if (updates.power2d_canvasWidth !== undefined) { builtinsData[6] = updates.power2d_canvasWidth; }');
  tsLines.push('      if (updates.power2d_canvasHeight !== undefined) { builtinsData[7] = updates.power2d_canvasHeight; }');
  tsLines.push('      if (updates.power2d_strokeThickness !== undefined) { builtinsData[8] = updates.power2d_strokeThickness; }');
  tsLines.push('      device.queue.writeBuffer(builtinsBuffer, 0, builtinsData);');
  tsLines.push('    },');
  tsLines.push('    setTexture: (name, texture) => {');
  tsLines.push('      textureViews[name] = texture;');
  tsLines.push('      rebuildBindGroup();');
  tsLines.push('    },');
  tsLines.push('    setCanvasSize: (width, height) => {');
  tsLines.push('      builtinsData[6] = width;');
  tsLines.push('      builtinsData[7] = height;');
  tsLines.push('      device.queue.writeBuffer(builtinsBuffer, 0, builtinsData);');
  tsLines.push('    },');
  tsLines.push('    dispose: () => {');
  tsLines.push('      uniformBuffer.destroy();');
  tsLines.push('      builtinsBuffer.destroy();');
  tsLines.push('    },');
  tsLines.push('  };');
  tsLines.push('');
  tsLines.push('  return instance;');
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export interface ${materialInterfaceName} extends MaterialDef<${uniformStruct.name}, ${shaderPrefix}TextureName> {}`);
  tsLines.push(`export const ${materialConstName}: ${materialInterfaceName} = {`);
  tsLines.push(`  createMaterial: create${shaderPrefix}Material,`);
  tsLines.push(`  uniformDefaults: ${uniformStruct.name}Defaults,`);
  tsLines.push(`  textureNames: ${shaderPrefix}TextureNames,`);
  tsLines.push('};');
  tsLines.push('');
  tsLines.push(`export default ${materialConstName};`);

  return { typesSource: `${tsLines.join('\n')}\n` };
}
