/**
 * WGSL â†’ raw WebGPU helper generator.
 *
 * Generates TypeScript companions for WGSL compute shaders, including:
 * - Uniform buffer helpers (f32 / i32 / u32 / bool scalars and vectors).
 * - Storage buffer packers/unpackers for reflected structs.
 * - Bind group layouts + bind group creation helpers.
 * - Compute pipeline creation helpers with raw WebGPU APIs.
 *
 * Missing features / TODOs:
 * - Binding arrays or bindless resource arrays.
 * - Texture arrays, cube textures, and explicit depth-texture helper typing.
 * - Overrides (@id) / specialization values and multi-entry compute pipelines.
 * - Module includes or splitting shaders across multiple files.
 */

import {
  ResourceType,
  StructInfo,
  TypeInfo,
  VariableInfo,
  WgslReflect,
} from 'wgsl_reflect';
import { toPascalCase, escapeTemplateLiteral } from '../../codegen-common/utils.ts';

export const RAW_SUFFIX = '.compute.wgsl';
export const RAW_OUTPUT_SUFFIX = '.raw.generated.ts';
const HEADER_COMMENT = '// Auto-generated by raw WGSL compute generator. DO NOT EDIT.';

interface TypeMapping {
  tsType: string;
  slotCount: number;
  valueLength: number;
  defaultExpression: string;
  componentType: 'f32' | 'i32' | 'u32' | 'bool';
  isVector: boolean;
}

function floatVectorMapping(componentCount: number, slotCount?: number): TypeMapping {
  const requiredSlots = slotCount ?? componentCount;
  return {
    tsType: 'Float32Array | readonly number[]',
    slotCount: requiredSlots,
    valueLength: componentCount,
    defaultExpression: `new Float32Array(${requiredSlots})`,
    componentType: 'f32',
    isVector: true,
  };
}

function intVectorMapping(componentCount: number, slotCount: number, unsigned: boolean): TypeMapping {
  const arrayCtor = unsigned ? 'Uint32Array' : 'Int32Array';
  const valueType = unsigned ? 'Uint32Array | readonly number[]' : 'Int32Array | readonly number[]';
  return {
    tsType: valueType,
    slotCount,
    valueLength: componentCount,
    defaultExpression: `new ${arrayCtor}(${slotCount})`,
    componentType: unsigned ? 'u32' : 'i32',
    isVector: true,
  };
}

const TYPE_MAP: Record<string, TypeMapping> = {
  f32: { tsType: 'number', slotCount: 1, valueLength: 1, defaultExpression: '0', componentType: 'f32', isVector: false },
  i32: { tsType: 'number', slotCount: 1, valueLength: 1, defaultExpression: '0', componentType: 'i32', isVector: false },
  u32: { tsType: 'number', slotCount: 1, valueLength: 1, defaultExpression: '0', componentType: 'u32', isVector: false },
  bool: { tsType: 'boolean', slotCount: 1, valueLength: 1, defaultExpression: 'false', componentType: 'bool', isVector: false },
  vec2f: floatVectorMapping(2),
  vec3f: floatVectorMapping(3, 4),
  vec4f: floatVectorMapping(4),
  mat4x4f: floatVectorMapping(16),
  vec2i: intVectorMapping(2, 2, false),
  vec3i: intVectorMapping(3, 4, false),
  vec4i: intVectorMapping(4, 4, false),
  vec2u: intVectorMapping(2, 2, true),
  vec3u: intVectorMapping(3, 4, true),
  vec4u: intVectorMapping(4, 4, true),
};

interface StructDescriptor {
  struct: StructInfo;
  interfaceName: string;
  layoutName: string;
  packFn: string;
}

interface UniformDescriptor {
  variable: VariableInfo;
  interfaceName: string;
  stateName: string;
  layoutName: string;
  createFn: string;
  updateFn: string;
  aliasCreate?: string;
  aliasUpdate?: string;
}

interface StorageDescriptor {
  variable: VariableInfo;
  stateName: string;
  layoutName: string;
  createFn: string;
  updateFn: string;
  writeFn: string;
  valueType: string;
}

function indent(lines: string[], spaces = 2): string {
  const pad = ' '.repeat(spaces);
  return lines
    .map((line) => (line.length > 0 ? pad + line : line))
    .join('\n');
}

function mappingFor(type: TypeInfo): TypeMapping | null {
  const name = type.getTypeName();
  if (TYPE_MAP[name]) {
    return TYPE_MAP[name];
  }
  if (type.isTemplate && (type as any).format) {
    const templateName = (type as any).name as string;
    const format = (type as any).format as TypeInfo;
    if (templateName === 'atomic') {
      return mappingFor(format);
    }
    const formatKey = format.getTypeName();
    if (templateName.startsWith('vec')) {
      const key = `${templateName}${formatKey[0]}`;
      if (TYPE_MAP[key]) {
        return TYPE_MAP[key];
      }
    }
  }
  return null;
}

function generateStructBlock(prefix: string, descriptor: StructDescriptor, structMap: Map<string, StructDescriptor>): string {
  const { struct, interfaceName, layoutName, packFn } = descriptor;
  const interfaceLines = struct.members.map((member) => {
    const mapping = mappingFor(member.type);
    const tsType = mapping ? mapping.tsType : member.type.isStruct ? `${prefix}${member.type.getTypeName()}` : 'number';
    return `${member.name}: ${tsType};`;
  });

  const layoutMembers = struct.members.map((member) => {
    const mapping = mappingFor(member.type);
    const slot = mapping ? mapping.slotCount : member.size / 4;
    return `  { name: '${member.name}', offset: ${member.offset}, size: ${member.size}, slot: ${slot} }`;
  });

  let needsIntView = false;
  let needsUintView = false;
  const packLines: string[] = [];

  struct.members.forEach((member) => {
    const mapping = mappingFor(member.type);
    const memberOffset = member.offset / 4;
    if (mapping) {
      if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
        needsIntView = true;
      }
      if (mapping.componentType === 'u32') {
        needsUintView = true;
      }
      const baseDecl = `const base = floatOffset + ${memberOffset};`;
      packLines.push('{');
      packLines.push(`  ${baseDecl}`);
      if (!mapping.isVector) {
        switch (mapping.componentType) {
          case 'f32':
            packLines.push(`  const raw = value.${member.name};`);
            packLines.push('  target[base] = raw !== undefined ? Number(raw) : 0;');
            break;
          case 'i32':
            packLines.push(`  const raw = value.${member.name};`);
            packLines.push('  intView[base] = raw !== undefined ? Math.trunc(raw as number) : 0;');
            break;
          case 'u32':
            packLines.push(`  const raw = value.${member.name};`);
            packLines.push('  uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;');
            break;
          case 'bool':
            packLines.push(`  const raw = value.${member.name};`);
            packLines.push('  intView[base] = raw ? 1 : 0;');
            break;
        }
      } else {
        const sourceVar = `${member.name}Source`;
        packLines.push(`  const ${sourceVar} = value.${member.name} as any;`);
        packLines.push(`  for (let i = 0; i < ${mapping.valueLength}; i++) {`);
        packLines.push(`    const component = ${sourceVar}?.[i];`);
        switch (mapping.componentType) {
          case 'f32':
            packLines.push('    target[base + i] = component !== undefined ? Number(component) : 0;');
            break;
          case 'i32':
            packLines.push('    intView[base + i] = component !== undefined ? Math.trunc(component as number) : 0;');
            break;
          case 'u32':
            packLines.push('    uintView[base + i] = component !== undefined ? Math.trunc(component as number) >>> 0 : 0;');
            break;
          case 'bool':
            packLines.push('    intView[base + i] = component ? 1 : 0;');
            break;
        }
        packLines.push('  }');
        if (mapping.slotCount > mapping.valueLength) {
          const padStart = mapping.valueLength;
          packLines.push(`  for (let i = ${padStart}; i < ${mapping.slotCount}; i++) {`);
          if (mapping.componentType === 'u32') {
            packLines.push('    uintView[base + i] = 0;');
          } else if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
            packLines.push('    intView[base + i] = 0;');
          } else {
            packLines.push('    target[base + i] = 0;');
          }
          packLines.push('  }');
        }
      }
      packLines.push('}');
    } else if (member.type.isStruct) {
      const nested = structMap.get(member.type.getTypeName());
      if (nested) {
        packLines.push('{');
        packLines.push(`  ${nested.packFn}(target, floatOffset + ${memberOffset}, value.${member.name});`);
        packLines.push('}');
      } else {
        packLines.push(`// ${member.name}: struct type ${member.type.getTypeName()} not recognized`);
      }
    } else {
      packLines.push(`// ${member.name}: unsupported type`);
    }
  });

  const preamble: string[] = [];
  if (needsIntView) {
    preamble.push('const intView = new Int32Array(target.buffer);');
  }
  if (needsUintView) {
    preamble.push('const uintView = new Uint32Array(target.buffer);');
  }

  return [
    `export interface ${interfaceName} {`,
    indent(interfaceLines),
    '}',
    '',
    `export const ${layoutName} = {`,
    `  size: ${struct.size},`,
    `  align: ${struct.align},`,
    '  members: [',
    layoutMembers.join(',\n'),
    '  ] as const,',
    '} as const;',
    '',
    `export function ${packFn}(target: Float32Array, floatOffset: number, value: ${interfaceName}): void {`,
    indent([...preamble, ...packLines].length ? [...preamble, ...packLines] : ['// No supported members']),
    '}',
  ].join('\n');
}

function generateUniformBlock(descriptor: UniformDescriptor, structDescriptor: StructDescriptor | undefined): string {
  const { interfaceName, stateName, layoutName, createFn, updateFn } = descriptor;
  const structMembers = structDescriptor?.struct.members ?? [];

  const layoutArray = structMembers.map((member) => {
    const mapping = mappingFor(member.type);
    const slot = mapping ? mapping.slotCount : member.size / 4;
    return `  { name: '${member.name}', slot: ${slot} }`;
  });

  const defaultAssignments = structMembers.map((member) => {
    const mapping = mappingFor(member.type);
    const defaultExpr = mapping ? mapping.defaultExpression : '0';
    return `  ${member.name}: ${defaultExpr},`;
  });

  const structSize = structDescriptor?.struct.size ?? 0;
  const alignedSize = Math.max(16, Math.ceil(structSize / 16) * 16);

  const createBody: string[] = [];
  createBody.push(`const data = new ArrayBuffer(${alignedSize});`);
  createBody.push('const floatView = new Float32Array(data);');
  if (defaultAssignments.length > 0) {
    createBody.push(`let uniforms: ${interfaceName} = {`);
    createBody.push(...defaultAssignments);
    createBody.push('};');
  } else {
    createBody.push(`let uniforms: ${interfaceName} = {} as ${interfaceName};`);
  }
  createBody.push('if (initial) {');
  createBody.push('  uniforms = { ...uniforms, ...initial };');
  createBody.push('}');
  if (structMembers.length > 0 && structDescriptor) {
    createBody.push(`${structDescriptor.packFn}(floatView, 0, uniforms);`);
  }
  createBody.push('const buffer = device.createBuffer({ size: data.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });');
  createBody.push('device.queue.writeBuffer(buffer, 0, data);');
  createBody.push('return { device, buffer, data, floatView, uniforms };');

  const updateBody: string[] = [];
  updateBody.push('if (!updates) {');
  updateBody.push('  return;');
  updateBody.push('}');
  updateBody.push('state.uniforms = { ...state.uniforms, ...updates };');
  if (structMembers.length > 0 && structDescriptor) {
    updateBody.push(`${structDescriptor.packFn}(state.floatView, 0, state.uniforms);`);
  }
  updateBody.push('state.device.queue.writeBuffer(state.buffer, 0, state.data);');

  const interfaceLines = structMembers.map((member) => {
    const mapping = mappingFor(member.type);
    const tsType = mapping ? mapping.tsType : 'number';
    return `${member.name}: ${tsType};`;
  });

  return [
    `const ${layoutName} = [`,
    layoutArray.join(',\n'),
    '] as const;',
    '',
    `export interface ${interfaceName} {`,
    indent(interfaceLines),
    '}',
    '',
    `export interface ${stateName} {`,
    '  device: GPUDevice;',
    '  buffer: GPUBuffer;',
    '  data: ArrayBuffer;',
    '  floatView: Float32Array;',
    `  uniforms: ${interfaceName};`,
    '}',
    '',
    `export function ${createFn}(device: GPUDevice, initial?: Partial<${interfaceName}>): ${stateName} {`,
    indent(createBody),
    '}',
    '',
    `export function ${updateFn}(state: ${stateName}, updates: Partial<${interfaceName}>): void {`,
    indent(updateBody),
    '}',
  ].join('\n');
}

function generateStorageBlock(descriptor: StorageDescriptor, structDescriptor: StructDescriptor | undefined): string {
  const { stateName, createFn, updateFn, writeFn, valueType } = descriptor;
  const byteStrideValue = structDescriptor ? structDescriptor.struct.size : descriptor.variable.stride || 0;

  const createBody: string[] = [];
  createBody.push(`const byteStride = ${byteStrideValue};`);
  createBody.push('const floatsPerElement = byteStride / Float32Array.BYTES_PER_ELEMENT;');
  createBody.push('const totalFloats = floatsPerElement * capacity;');
  createBody.push('const data = new Float32Array(totalFloats);');
  createBody.push('const usage = options?.usage ?? (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);');
  createBody.push('const buffer = device.createBuffer({ size: byteStride * capacity, usage });');
  createBody.push('if (options?.initial) {');
  if (structDescriptor) {
    createBody.push('  options.initial.slice(0, capacity).forEach((value, index) => {');
    createBody.push(`    ${structDescriptor.packFn}(data, index * floatsPerElement, value);`);
    createBody.push('  });');
  } else {
    createBody.push('  data.set(options.initial.flat().slice(0, totalFloats));');
  }
  createBody.push('  device.queue.writeBuffer(buffer, 0, data);');
  createBody.push('}');
  createBody.push('return { device, buffer, data, capacity, floatsPerElement };');

  const writeBody: string[] = [];
  if (structDescriptor) {
    writeBody.push('const offset = index * state.floatsPerElement;');
    writeBody.push(`${structDescriptor.packFn}(state.data, offset, value);`);
  } else {
    writeBody.push('const offset = index * state.floatsPerElement;');
    writeBody.push('for (let i = 0; i < state.floatsPerElement; i++) {');
    writeBody.push('  state.data[offset + i] = value[i] ?? 0;');
    writeBody.push('}');
  }

  return [
    `export interface ${stateName} {`,
    '  device: GPUDevice;',
    '  buffer: GPUBuffer;',
    '  data: Float32Array;',
    '  capacity: number;',
    '  floatsPerElement: number;',
    '}',
    '',
    `export function ${createFn}(device: GPUDevice, capacity: number, options?: { initial?: ${valueType}[]; usage?: GPUBufferUsageFlags; }): ${stateName} {`,
    indent(createBody),
    '}',
    '',
    `export function ${writeFn}(state: ${stateName}, index: number, value: ${valueType}): void {`,
    indent(writeBody),
    '}',
    '',
    `export function ${updateFn}(state: ${stateName}): void {`,
    indent(['state.device.queue.writeBuffer(state.buffer, 0, state.data);']),
    '}',
  ].join('\n');
}

function classify(variable: VariableInfo): 'storage' | 'uniform' | 'texture' | 'sampler' | 'storageTexture' {
  switch (variable.resourceType) {
    case ResourceType.Uniform:
      return 'uniform';
    case ResourceType.Storage:
      return 'storage';
    case ResourceType.Texture:
      return 'texture';
    case ResourceType.Sampler:
      return 'sampler';
    case ResourceType.StorageTexture:
      return 'storageTexture';
    default:
      return 'storage';
  }
}

function normalizeAccess(access?: string): string {
  return String(access ?? '').replace(/[-_]/g, '').toLowerCase();
}

function storageBufferType(access?: string): 'read-only-storage' | 'storage' {
  const normalized = normalizeAccess(access);
  return normalized === 'read' || normalized === 'readonly' ? 'read-only-storage' : 'storage';
}

function textureViewDimension(typeName: string): { viewDimension: GPUTextureViewDimension; multisampled: boolean } {
  const multisampled = typeName.includes('multisampled');
  if (typeName.includes('1d')) {
    return { viewDimension: '1d', multisampled };
  }
  if (typeName.includes('2d_array')) {
    return { viewDimension: '2d-array', multisampled };
  }
  if (typeName.includes('3d')) {
    return { viewDimension: '3d', multisampled };
  }
  if (typeName.includes('cube_array')) {
    return { viewDimension: 'cube-array', multisampled };
  }
  if (typeName.includes('cube')) {
    return { viewDimension: 'cube', multisampled };
  }
  return { viewDimension: '2d', multisampled };
}

function textureSampleType(typeName: string): GPUTextureSampleType {
  if (typeName.startsWith('texture_depth')) {
    return 'depth';
  }
  const match = typeName.match(/<\\s*(f32|i32|u32)\\s*>/);
  if (!match) {
    return 'float';
  }
  switch (match[1]) {
    case 'i32':
      return 'sint';
    case 'u32':
      return 'uint';
    default:
      return 'float';
  }
}

function storageTextureInfo(typeName: string): { format: GPUTextureFormat; access: GPUStorageTextureAccess; viewDimension: GPUTextureViewDimension } {
  const formatMatch = typeName.match(/<\\s*([^,>\\s]+)\\s*,\\s*([^>\\s]+)\\s*>/);
  const format = (formatMatch?.[1] ?? 'rgba8unorm') as GPUTextureFormat;
  const accessRaw = normalizeAccess(formatMatch?.[2]);
  let access: GPUStorageTextureAccess = 'write-only';
  if (accessRaw === 'read') {
    access = 'read-only';
  } else if (accessRaw === 'readwrite') {
    access = 'read-write';
  }
  const { viewDimension } = textureViewDimension(typeName);
  return { format, access, viewDimension };
}

function samplerBindingType(typeName: string): GPUSamplerBindingType {
  if (typeName.includes('comparison')) {
    return 'comparison';
  }
  return 'filtering';
}

function generateShaderFactory(
  shaderIdentifier: string,
  shaderSourceRef: string,
  bindings: Array<{ variable: VariableInfo; kind: ReturnType<typeof classify>; typeRef: string }>,
  uniforms: UniformDescriptor[],
): string {
  const mappingEntries = bindings.map(
    (entry) => `    ${entry.variable.name}: { group: ${entry.variable.group ?? 0}, binding: ${entry.variable.binding ?? 0} }`,
  );

  const interfaceLines = bindings.map((entry) => {
    if (entry.kind === 'uniform') {
      const uniform = uniforms.find((u) => u.variable === entry.variable);
      return `  ${entry.variable.name}: ${uniform ? uniform.stateName : 'GPUBuffer'};`;
    }
    return `  ${entry.variable.name}: ${entry.typeRef};`;
  });

  const groups = new Map<number, Array<{ variable: VariableInfo; kind: ReturnType<typeof classify> }>>();
  bindings.forEach((entry) => {
    const group = entry.variable.group ?? 0;
    const list = groups.get(group) ?? [];
    list.push({ variable: entry.variable, kind: entry.kind });
    groups.set(group, list);
  });

  const groupIndices = Array.from(groups.keys()).sort((a, b) => a - b);
  const maxGroup = groupIndices.length ? Math.max(...groupIndices) : 0;

  const groupLayoutLines: string[] = [];
  const groupBindLines: string[] = [];

  groupIndices.forEach((group) => {
    const entries = [...(groups.get(group) ?? [])].sort((a, b) => (a.variable.binding ?? 0) - (b.variable.binding ?? 0));
    const layoutLines: string[] = [];
    const bindLines: string[] = [];
    entries.forEach((entry) => {
      const binding = entry.variable.binding ?? 0;
      const typeName = entry.variable.type.getTypeName();
      switch (entry.kind) {
        case 'uniform':
          layoutLines.push(`{ binding: ${binding}, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },`);
          bindLines.push(`{ binding: ${binding}, resource: { buffer: bindings.${entry.variable.name}.buffer } },`);
          break;
        case 'storage': {
          const bufferType = storageBufferType(entry.variable);
          layoutLines.push(`{ binding: ${binding}, visibility: GPUShaderStage.COMPUTE, buffer: { type: '${bufferType}' } },`);
          bindLines.push(`{ binding: ${binding}, resource: { buffer: bindings.${entry.variable.name} } },`);
          break;
        }
        case 'texture': {
          const { viewDimension, multisampled } = textureViewDimension(typeName);
          const sampleType = textureSampleType(typeName);
          layoutLines.push(`{ binding: ${binding}, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: '${sampleType}', viewDimension: '${viewDimension}', multisampled: ${multisampled} } },`);
          bindLines.push(`{ binding: ${binding}, resource: bindings.${entry.variable.name} },`);
          break;
        }
        case 'sampler': {
          const samplerType = samplerBindingType(typeName);
          layoutLines.push(`{ binding: ${binding}, visibility: GPUShaderStage.COMPUTE, sampler: { type: '${samplerType}' } },`);
          bindLines.push(`{ binding: ${binding}, resource: bindings.${entry.variable.name} },`);
          break;
        }
        case 'storageTexture': {
          const info = storageTextureInfo(typeName);
          layoutLines.push(`{ binding: ${binding}, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: '${info.access}', format: '${info.format}', viewDimension: '${info.viewDimension}' } },`);
          bindLines.push(`{ binding: ${binding}, resource: bindings.${entry.variable.name} },`);
          break;
        }
        default:
          break;
      }
    });

    if (layoutLines.length) {
      groupLayoutLines.push(`bindGroupLayouts[${group}] = device.createBindGroupLayout({ entries: [`);
      groupLayoutLines.push(...layoutLines.map((line) => `  ${line}`));
      groupLayoutLines.push('] });');
    } else {
      groupLayoutLines.push(`bindGroupLayouts[${group}] = device.createBindGroupLayout({ entries: [] });`);
    }

    if (bindLines.length) {
      groupBindLines.push(`groups[${group}] = device.createBindGroup({`);
      groupBindLines.push(`  layout: bindGroupLayouts[${group}],`);
      groupBindLines.push('  entries: [');
      groupBindLines.push(...bindLines.map((line) => `    ${line}`));
      groupBindLines.push('  ],');
      groupBindLines.push('});');
    }
  });

  const updateLines: string[] = [];
  bindings.forEach((entry) => {
    const name = entry.variable.name;
    updateLines.push(`if (updates.${name} !== undefined) {`);
    updateLines.push(`  state.bindings.${name} = updates.${name}!;`);
    updateLines.push('  dirty = true;');
    updateLines.push('}');
  });

  const bindingInterfaceName = 'ShaderBindings';
  const stateInterfaceName = 'ShaderState';
  const createFunctionName = 'createShader';
  const updateFunctionName = 'updateBindings';

  return [
    'const bindingLayout = {',
    mappingEntries.join(',\n'),
    '};',
    '',
    `export interface ${bindingInterfaceName} {`,
    indent(interfaceLines),
    '}',
    '',
    `export interface ${stateInterfaceName} {`,
    '  device: GPUDevice;',
    '  pipeline: GPUComputePipeline;',
    '  bindGroupLayouts: GPUBindGroupLayout[];',
    '  bindGroups: GPUBindGroup[];',
    `  bindings: ${bindingInterfaceName};`,
    '}',
    '',
    `function buildBindGroups(device: GPUDevice, bindGroupLayouts: GPUBindGroupLayout[], bindings: ${bindingInterfaceName}): GPUBindGroup[] {`,
    indent([
      'const groups: GPUBindGroup[] = [];',
      ...groupBindLines,
      'for (let i = 0; i < bindGroupLayouts.length; i++) {',
      '  if (!groups[i]) {',
      '    groups[i] = device.createBindGroup({ layout: bindGroupLayouts[i], entries: [] });',
      '  }',
      '}',
      'return groups;',
    ]),
    '}',
    '',
    `export function ${createFunctionName}(device: GPUDevice, bindings: ${bindingInterfaceName}, options?: { entryPoint?: string; source?: string; label?: string; }): ${stateInterfaceName} {`,
    indent([
      'const bindGroupLayouts: GPUBindGroupLayout[] = [];',
      ...groupLayoutLines,
      `for (let i = 0; i <= ${maxGroup}; i++) {`,
      '  if (!bindGroupLayouts[i]) {',
      '    bindGroupLayouts[i] = device.createBindGroupLayout({ entries: [] });',
      '  }',
      '}',
      `const label = options?.label ?? '${shaderIdentifier}';`,
      `const shaderModule = device.createShaderModule({ label, code: options?.source ?? ${shaderSourceRef} });`,
      'const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts });',
      'const pipeline = device.createComputePipeline({ label, layout: pipelineLayout, compute: { module: shaderModule, entryPoint: options?.entryPoint ?? \'main\' } });',
      'const bindGroups = buildBindGroups(device, bindGroupLayouts, bindings);',
      'return { device, pipeline, bindGroupLayouts, bindGroups, bindings };',
    ]),
    '}',
    '',
    `export function ${updateFunctionName}(state: ${stateInterfaceName}, updates: Partial<${bindingInterfaceName}>): void {`,
    indent([
      'let dirty = false;',
      ...(updateLines.length ? updateLines : ['// Nothing to update']),
      'if (!dirty) {',
      '  return;',
      '}',
      'state.bindGroups = buildBindGroups(state.device, state.bindGroupLayouts, state.bindings);',
    ]),
    '}',
  ].join('\n');
}

export interface GenerateComputeShaderTypesSourceOptions {
  shaderCode: string;
  shaderFileName: string;
  shaderStem: string;
}

export interface GenerateComputeShaderTypesSourceResult {
  typesSource: string;
  shaderPrefix: string;
}

export function generateComputeShaderTypesSource(options: GenerateComputeShaderTypesSourceOptions): GenerateComputeShaderTypesSourceResult {
  const { shaderCode, shaderStem } = options;
  const reflect = new WgslReflect(shaderCode);

  const sanitizedBaseName = shaderStem.replace(/\.compute$/i, '');
  const shaderPrefix = toPascalCase(sanitizedBaseName);

  const usedStructs = reflect.structs.filter((s) => s.inUse);
  const structDescriptors = usedStructs.map<StructDescriptor>((struct) => ({
    struct,
    interfaceName: `${shaderPrefix}${struct.name}`,
    layoutName: `${shaderPrefix}${struct.name}Layout`,
    packFn: `pack${shaderPrefix}${struct.name}`,
  }));

  const structDescriptorMap = new Map<string, StructDescriptor>();
  structDescriptors.forEach((descriptor) => {
    structDescriptorMap.set(descriptor.struct.name, descriptor);
  });

  const structBlocks = structDescriptors.map((descriptor) => generateStructBlock(shaderPrefix, descriptor, structDescriptorMap));

  const uniformDescriptors: UniformDescriptor[] = reflect.uniforms.map((variable) => {
    const pascalName = toPascalCase(variable.name);
    return {
      variable,
      interfaceName: `${pascalName}Uniforms`,
      stateName: `${pascalName}UniformState`,
      layoutName: `uniformLayout_${variable.name}`,
      createFn: `createUniformBuffer_${variable.name}`,
      updateFn: `updateUniformBuffer_${variable.name}`,
      aliasCreate: undefined,
      aliasUpdate: undefined,
    };
  });

  if (uniformDescriptors.length === 1) {
    uniformDescriptors[0].aliasCreate = 'createUniformBuffer';
    uniformDescriptors[0].aliasUpdate = 'updateUniformBuffer';
  }

  const uniformBlocks = uniformDescriptors.map((descriptor) => {
    const struct = structDescriptors.find((entry) => entry.struct.name === descriptor.variable.type.getTypeName());
    return generateUniformBlock(descriptor, struct);
  });

  const storageDescriptors: StorageDescriptor[] = reflect.storage.map((variable) => {
    const pascalName = toPascalCase(variable.name);
    const struct = structDescriptors.find((entry) => entry.struct.name === variable.format?.getTypeName());
    const valueType = struct ? struct.interfaceName : 'number[]';
    return {
      variable,
      stateName: `${pascalName}StorageState`,
      layoutName: struct ? struct.layoutName : `storageLayout_${variable.name}`,
      createFn: `createStorageBuffer_${variable.name}`,
      updateFn: `updateStorageBuffer_${variable.name}`,
      writeFn: `writeStorageValue_${variable.name}`,
      valueType,
    };
  });

  const storageBlocks = storageDescriptors.map((descriptor) => {
    const struct = structDescriptors.find((entry) => entry.struct.name === descriptor.variable.format?.getTypeName());
    return generateStorageBlock(descriptor, struct);
  });

  const sampledTextureVariables = reflect.textures.filter((variable) => variable.resourceType === ResourceType.Texture);
  const storageTextureVariablesReflect = reflect.textures.filter((variable) => variable.resourceType === ResourceType.StorageTexture);

  const textureDescriptors = sampledTextureVariables.map((variable) => ({
    variable,
    kind: classify(variable),
    typeRef: 'GPUTextureView',
  }));

  const samplerDescriptors = reflect.samplers.map((variable) => ({
    variable,
    kind: classify(variable),
    typeRef: 'GPUSampler',
  }));

  const storageTextureDescriptors = storageTextureVariablesReflect.map((variable) => ({
    variable,
    kind: classify(variable),
    typeRef: 'GPUTextureView',
  }));

  const shaderBindings = [
    ...reflect.uniforms.map((variable) => ({
      variable,
      kind: classify(variable),
      typeRef: 'GPUBuffer',
    })),
    ...reflect.storage.map((variable) => ({
      variable,
      kind: classify(variable),
      typeRef: 'GPUBuffer',
    })),
    ...textureDescriptors,
    ...samplerDescriptors,
    ...storageTextureDescriptors,
  ];

  const shaderFactory = generateShaderFactory(
    sanitizedBaseName,
    `${shaderPrefix}Source`,
    shaderBindings,
    uniformDescriptors,
  );

  const aliasLines = uniformDescriptors
    .filter((descriptor) => descriptor.aliasCreate && descriptor.aliasUpdate)
    .map((descriptor) =>
      [`export const ${descriptor.aliasCreate} = ${descriptor.createFn};`, `export const ${descriptor.aliasUpdate} = ${descriptor.updateFn};`].join('\n'),
    );

  const fileSections: string[] = [
    HEADER_COMMENT,
    `export const ${shaderPrefix}Source = ${escapeTemplateLiteral(shaderCode.trimEnd())};`,
    '',
    ...structBlocks,
    structBlocks.length ? '' : '',
    ...uniformBlocks,
    uniformBlocks.length ? '' : '',
    ...storageBlocks,
    storageBlocks.length ? '' : '',
    shaderFactory,
    aliasLines.join('\n'),
  ].filter((section) => section !== '');

  const typesSource = fileSections.join('\n\n');

  return { typesSource, shaderPrefix };
}
