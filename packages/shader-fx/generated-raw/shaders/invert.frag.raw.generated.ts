// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
import { CustomShaderEffect, type ShaderSource, type UniformDescriptor, type MaterialHandles, type ShaderUniforms, type Dynamic } from '@avtools/shader-fx/raw';
export const InvertVertexSource = `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) vUV: vec2f,
};

@vertex
fn main(@builtin(vertex_index) index: u32) -> VertexOutput {
  var positions = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f(3.0, -1.0),
    vec2f(-1.0, 3.0),
  );
  var uvs = array<vec2f, 3>(
    vec2f(0.0, 0.0),
    vec2f(2.0, 0.0),
    vec2f(0.0, 2.0),
  );
  var out: VertexOutput;
  out.position = vec4f(positions[index], 0.0, 1.0);
  out.vUV = uvs[index];
  return out;
}

`;
export const InvertFragmentSources = [
  `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct InvertUniforms {
  strength: f32,
};

fn pass0(uv: vec2f, uniforms: InvertUniforms, src: texture_2d<f32>, srcSampler: sampler) -> vec4f {
  let color = textureSample(src, srcSampler, uv);
  let inverted = vec4f(1.0 - color.rgb, color.a);
  return mix(color, inverted, uniforms.strength);
}

@group(0) @binding(0) var<uniform> uniforms: InvertUniforms;
@group(0) @binding(1) var src: texture_2d<f32>;
@group(0) @binding(2) var srcSampler: sampler;

struct FragmentInput {
  @location(0) vUV: vec2f,
};

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  let uv_local = input.vUV;
  let uniforms_value = uniforms;
  let color = pass0(uv_local, uniforms_value, src, srcSampler);
  return color;
}

`, // pass0
] as const;
export const InvertPassCount = 1 as const;
export const InvertPrimaryTextureName = 'src' as const;

export const InvertPassTextureSources = [
  [
    { binding: 'src', source: { kind: 'input', key: 'src' } },
  ],
] as const;

export const InvertUniformMeta: UniformDescriptor[] = [
  {
    name: 'strength',
    kind: 'f32',
    bindingName: 'uniforms_strength',
  },
];

export interface InvertUniforms {
  strength: number;
}

export const InvertUniformsDefaults: InvertUniforms = {
  strength: 0,
};

const InvertUniformsLayoutSize = 4;

function packInvertUniforms(floatView: Float32Array, intView: Int32Array, uintView: Uint32Array, floatOffset: number, value: InvertUniforms): void {
  {
    const base = floatOffset + 0;
    const raw = value.strength;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
}

export type InvertTextureName = 'src';
export const InvertTextureNames = ['src'] as const;
export interface InvertInputs {
  src: ShaderSource;
}

export type InvertMaterialHandles = MaterialHandles<InvertUniforms, InvertTextureName>;

export interface InvertMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createInvertMaterial(device: GPUDevice, format: GPUTextureFormat, options: InvertMaterialOptions = {}): InvertMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 1) {
    throw new Error(`Invalid passIndex ${passIndex} for Invert. Expected 0 <= passIndex < 1.`);
  }
  const uniformData = new ArrayBuffer(InvertUniformsLayoutSize);
  const uniformFloats = new Float32Array(uniformData);
  const uniformInts = new Int32Array(uniformData);
  const uniformUints = new Uint32Array(uniformData);
  let currentUniforms: InvertUniforms = { ...InvertUniformsDefaults };
  packInvertUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
  const uniformBuffer = device.createBuffer({ size: uniformData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);

  const bindGroupLayout = device.createBindGroupLayout({ entries: [
    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
  ] });

  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
  const vertexModule = device.createShaderModule({ code: InvertVertexSource });
  const fragmentModule = device.createShaderModule({ code: InvertFragmentSources[passIndex] });

  const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    vertex: { module: vertexModule, entryPoint: "main" },
    fragment: { module: fragmentModule, entryPoint: "main", targets: [{ format }] },
    primitive: { topology: "triangle-list", cullMode: "none" },
  });

  const samplers: Record<string, GPUSampler> = {};
  const textureViews: Record<string, GPUTextureView> = {};
  for (const name of InvertTextureNames) {
    samplers[name] = device.createSampler({ magFilter: "linear", minFilter: "linear" });
    const placeholder = device.createTexture({ size: { width: 1, height: 1 }, format, usage: GPUTextureUsage.TEXTURE_BINDING });
    textureViews[name] = placeholder.createView();
  }

  let bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: textureViews['src'] },
      { binding: 2, resource: samplers['src'] },
    ],
  });

  const rebuildBindGroup = () => {
    bindGroup = device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: textureViews['src'] },
        { binding: 2, resource: samplers['src'] },
      ],
    });
  };

  const handles: InvertMaterialHandles = {
    pipeline,
    get bindGroup() { return bindGroup; },
    setTexture: (name, texture) => {
      textureViews[name] = texture;
      rebuildBindGroup();
    },
    setUniforms: (updates) => {
      currentUniforms = { ...currentUniforms, ...updates };
      packInvertUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
      device.queue.writeBuffer(uniformBuffer, 0, uniformData);
    },
  };

  return handles;
}

export class InvertEffect extends CustomShaderEffect<InvertUniforms, InvertInputs> {
  effectName = 'Invert';

  constructor(device: GPUDevice, inputs: InvertInputs, width = 1280, height = 720, format: GPUTextureFormat = 'rgba16float', clearColor: GPUColor = { r: 0, g: 0, b: 0, a: 1 }) {
    super(device, inputs, {
      factory: (deviceRef, formatRef, options) => createInvertMaterial(deviceRef, formatRef, options),
      textureInputKeys: ['src'],
      textureBindingKeys: InvertTextureNames,
      passTextureSources: InvertPassTextureSources,
      passCount: 1,
      primaryTextureKey: 'src',
      width,
      height,
      format,
      clearColor,
      uniformMeta: InvertUniformMeta,
    });
  }

  override setUniforms(uniforms: { strength?: Dynamic<number> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.strength !== undefined) {
      record['strength'] = uniforms.strength;
    }
    super.setUniforms(record);
  }
}

