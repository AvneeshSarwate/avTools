// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
import { CustomShaderEffect, type ShaderSource, type UniformDescriptor, type MaterialHandles, type ShaderUniforms, type Dynamic } from '@avtools/shader-fx/raw';
export const VerticalBlurVertexSource = `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) vUV: vec2f,
};

@vertex
fn main(@builtin(vertex_index) index: u32) -> VertexOutput {
  var positions = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f(3.0, -1.0),
    vec2f(-1.0, 3.0),
  );
  var uvs = array<vec2f, 3>(
    vec2f(0.0, 1.0),
    vec2f(2.0, 1.0),
    vec2f(0.0, -1.0),
  );
  var out: VertexOutput;
  out.position = vec4f(positions[index], 0.0, 1.0);
  out.vUV = uvs[index];
  return out;
}

`;
export const VerticalBlurFragmentSources = [
  `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct VerticalBlurUniforms {
  pixels: i32,
  resolution: f32,
};

fn pass0(uv: vec2f, uniforms: VerticalBlurUniforms, src: texture_2d<f32>, srcSampler: sampler) -> vec4f {
  // Skip blur if pixels is 0 - just pass through
  if (uniforms.pixels <= 0) {
    return textureSample(src, srcSampler, uv);
  }

  var color = vec4f(0.0);
  var total = 0.0;
  let offset = 1.0 / uniforms.resolution;
  var i: i32 = -uniforms.pixels;
  loop {
    let weight = 1.0 - (abs(f32(i)) / f32(uniforms.pixels + 1));
    let sampleUV = uv + vec2f(0.0, offset * f32(i));
    color = color + textureSample(src, srcSampler, sampleUV) * weight;
    total = total + weight;
    if (i >= uniforms.pixels) {
      break;
    }
    i = i + 1;
  }
  return color / total;
}

@group(0) @binding(0) var<uniform> uniforms: VerticalBlurUniforms;
@group(0) @binding(1) var src: texture_2d<f32>;
@group(0) @binding(2) var srcSampler: sampler;

struct FragmentInput {
  @location(0) vUV: vec2f,
};

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  let uv_local = input.vUV;
  let uniforms_value = uniforms;
  let color = pass0(uv_local, uniforms_value, src, srcSampler);
  return color;
}

`, // pass0
] as const;
export const VerticalBlurPassCount = 1 as const;
export const VerticalBlurPrimaryTextureName = 'src' as const;

export const VerticalBlurPassTextureSources = [
  [
    { binding: 'src', source: { kind: 'input', key: 'src' } },
  ],
] as const;

export const VerticalBlurUniformMeta: UniformDescriptor[] = [
  {
    name: 'pixels',
    kind: 'i32',
    bindingName: 'uniforms_pixels',
  },
  {
    name: 'resolution',
    kind: 'f32',
    bindingName: 'uniforms_resolution',
  },
];

export interface VerticalBlurUniforms {
  pixels: number;
  resolution: number;
}

export const VerticalBlurUniformsDefaults: VerticalBlurUniforms = {
  pixels: 0,
  resolution: 0,
};

const VerticalBlurUniformsLayoutSize = 8;

function packVerticalBlurUniforms(floatView: Float32Array, intView: Int32Array, uintView: Uint32Array, floatOffset: number, value: VerticalBlurUniforms): void {
  {
    const base = floatOffset + 0;
    const raw = value.pixels;
    intView[base] = raw !== undefined ? Math.trunc(raw as number) : 0;
  }
  {
    const base = floatOffset + 1;
    const raw = value.resolution;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
}

export type VerticalBlurTextureName = 'src';
export const VerticalBlurTextureNames = ['src'] as const;
export interface VerticalBlurInputs {
  src: ShaderSource;
}

export type VerticalBlurMaterialHandles = MaterialHandles<VerticalBlurUniforms, VerticalBlurTextureName>;

export interface VerticalBlurMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createVerticalBlurMaterial(device: GPUDevice, format: GPUTextureFormat, options: VerticalBlurMaterialOptions = {}): VerticalBlurMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 1) {
    throw new Error(`Invalid passIndex ${passIndex} for VerticalBlur. Expected 0 <= passIndex < 1.`);
  }
  const uniformData = new ArrayBuffer(VerticalBlurUniformsLayoutSize);
  const uniformFloats = new Float32Array(uniformData);
  const uniformInts = new Int32Array(uniformData);
  const uniformUints = new Uint32Array(uniformData);
  let currentUniforms: VerticalBlurUniforms = { ...VerticalBlurUniformsDefaults };
  packVerticalBlurUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
  const uniformBuffer = device.createBuffer({ size: uniformData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);

  const bindGroupLayout = device.createBindGroupLayout({ entries: [
    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
  ] });

  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
  const vertexModule = device.createShaderModule({ code: VerticalBlurVertexSource });
  const fragmentModule = device.createShaderModule({ code: VerticalBlurFragmentSources[passIndex] });

  const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    vertex: { module: vertexModule, entryPoint: "main" },
    fragment: { module: fragmentModule, entryPoint: "main", targets: [{ format }] },
    primitive: { topology: "triangle-list", cullMode: "none" },
  });

  const samplers: Record<string, GPUSampler> = {};
  const textureViews: Record<string, GPUTextureView> = {};
  for (const name of VerticalBlurTextureNames) {
    samplers[name] = device.createSampler({ magFilter: "linear", minFilter: "linear" });
    const placeholder = device.createTexture({ size: { width: 1, height: 1 }, format, usage: GPUTextureUsage.TEXTURE_BINDING });
    textureViews[name] = placeholder.createView();
  }

  let bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: textureViews['src'] },
      { binding: 2, resource: samplers['src'] },
    ],
  });

  const rebuildBindGroup = () => {
    bindGroup = device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: textureViews['src'] },
        { binding: 2, resource: samplers['src'] },
      ],
    });
  };

  const handles: VerticalBlurMaterialHandles = {
    pipeline,
    get bindGroup() { return bindGroup; },
    setTexture: (name, texture) => {
      textureViews[name] = texture;
      rebuildBindGroup();
    },
    setUniforms: (updates) => {
      currentUniforms = { ...currentUniforms, ...updates };
      packVerticalBlurUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
      device.queue.writeBuffer(uniformBuffer, 0, uniformData);
    },
  };

  return handles;
}

export class VerticalBlurEffect extends CustomShaderEffect<VerticalBlurUniforms, VerticalBlurInputs> {
  override effectName = 'VerticalBlur';

  constructor(device: GPUDevice, inputs: VerticalBlurInputs, width = 1280, height = 720, format: GPUTextureFormat = 'rgba16float', clearColor: GPUColor = { r: 0, g: 0, b: 0, a: 1 }) {
    super(device, inputs, {
      factory: (deviceRef, formatRef, options) => createVerticalBlurMaterial(deviceRef, formatRef, options),
      textureInputKeys: ['src'],
      textureBindingKeys: VerticalBlurTextureNames,
      passTextureSources: VerticalBlurPassTextureSources,
      passCount: 1,
      primaryTextureKey: 'src',
      width,
      height,
      format,
      clearColor,
      uniformMeta: VerticalBlurUniformMeta,
    });
  }

  override setUniforms(uniforms: { pixels?: Dynamic<number>, resolution?: Dynamic<number> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.pixels !== undefined) {
      record['pixels'] = uniforms.pixels;
    }
    if (uniforms.resolution !== undefined) {
      record['resolution'] = uniforms.resolution;
    }
    super.setUniforms(record);
  }
}

