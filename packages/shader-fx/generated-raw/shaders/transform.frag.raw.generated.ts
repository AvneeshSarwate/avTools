// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
import { CustomShaderEffect, type ShaderSource, type UniformDescriptor, type MaterialHandles, type ShaderUniforms, type Dynamic } from '@avtools/shader-fx/raw';
export const TransformVertexSource = `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) vUV: vec2f,
};

@vertex
fn main(@builtin(vertex_index) index: u32) -> VertexOutput {
  var positions = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f(3.0, -1.0),
    vec2f(-1.0, 3.0),
  );
  var uvs = array<vec2f, 3>(
    vec2f(0.0, 1.0),
    vec2f(2.0, 1.0),
    vec2f(0.0, -1.0),
  );
  var out: VertexOutput;
  out.position = vec4f(positions[index], 0.0, 1.0);
  out.vUV = uvs[index];
  return out;
}

`;
export const TransformFragmentSources = [
  `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct TransformUniforms {
  rotate: f32,
  anchor: vec2f,
  translate: vec2f,
  scale: vec2f,
};

fn pass0(uv: vec2f, uniforms: TransformUniforms, src: texture_2d<f32>, srcSampler: sampler) -> vec4f {
  var uvLocal = uv - uniforms.anchor;
  uvLocal = uvLocal * uniforms.scale;
  let cosR = cos(uniforms.rotate);
  let sinR = sin(uniforms.rotate);
  let rotated = vec2f(
    uvLocal.x * cosR - uvLocal.y * sinR,
    uvLocal.x * sinR + uvLocal.y * cosR,
  ) + uniforms.anchor + uniforms.translate;
  return textureSample(src, srcSampler, rotated);
}

@group(0) @binding(0) var<uniform> uniforms: TransformUniforms;
@group(0) @binding(1) var src: texture_2d<f32>;
@group(0) @binding(2) var srcSampler: sampler;

struct FragmentInput {
  @location(0) vUV: vec2f,
};

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  let uv_local = input.vUV;
  let uniforms_value = uniforms;
  let color = pass0(uv_local, uniforms_value, src, srcSampler);
  return color;
}

`, // pass0
] as const;
export const TransformPassCount = 1 as const;
export const TransformPrimaryTextureName = 'src' as const;

export const TransformPassTextureSources = [
  [
    { binding: 'src', source: { kind: 'input', key: 'src' } },
  ],
] as const;

export const TransformUniformMeta: UniformDescriptor[] = [
  {
    name: 'rotate',
    kind: 'f32',
    bindingName: 'uniforms_rotate',
  },
  {
    name: 'anchor',
    kind: 'vec2f',
    bindingName: 'uniforms_anchor',
  },
  {
    name: 'translate',
    kind: 'vec2f',
    bindingName: 'uniforms_translate',
  },
  {
    name: 'scale',
    kind: 'vec2f',
    bindingName: 'uniforms_scale',
  },
];

export interface TransformUniforms {
  rotate: number;
  anchor: readonly [number, number];
  translate: readonly [number, number];
  scale: readonly [number, number];
}

export const TransformUniformsDefaults: TransformUniforms = {
  rotate: 0,
  anchor: [0, 0],
  translate: [0, 0],
  scale: [0, 0],
};

const TransformUniformsLayoutSize = 32;

function packTransformUniforms(floatView: Float32Array, intView: Int32Array, uintView: Uint32Array, floatOffset: number, value: TransformUniforms): void {
  {
    const base = floatOffset + 0;
    const raw = value.rotate;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 2;
    const value_anchor = value.anchor as any;
    for (let i = 0; i < 2; i++) {
      const component = value_anchor?.[i];
      floatView[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
  {
    const base = floatOffset + 4;
    const value_translate = value.translate as any;
    for (let i = 0; i < 2; i++) {
      const component = value_translate?.[i];
      floatView[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
  {
    const base = floatOffset + 6;
    const value_scale = value.scale as any;
    for (let i = 0; i < 2; i++) {
      const component = value_scale?.[i];
      floatView[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
}

export type TransformTextureName = 'src';
export const TransformTextureNames = ['src'] as const;
export interface TransformInputs {
  src: ShaderSource;
}

export type TransformMaterialHandles = MaterialHandles<TransformUniforms, TransformTextureName>;

export interface TransformMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createTransformMaterial(device: GPUDevice, format: GPUTextureFormat, options: TransformMaterialOptions = {}): TransformMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 1) {
    throw new Error(`Invalid passIndex ${passIndex} for Transform. Expected 0 <= passIndex < 1.`);
  }
  const uniformData = new ArrayBuffer(TransformUniformsLayoutSize);
  const uniformFloats = new Float32Array(uniformData);
  const uniformInts = new Int32Array(uniformData);
  const uniformUints = new Uint32Array(uniformData);
  let currentUniforms: TransformUniforms = { ...TransformUniformsDefaults };
  packTransformUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
  const uniformBuffer = device.createBuffer({ size: uniformData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);

  const bindGroupLayout = device.createBindGroupLayout({ entries: [
    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
  ] });

  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
  const vertexModule = device.createShaderModule({ code: TransformVertexSource });
  const fragmentModule = device.createShaderModule({ code: TransformFragmentSources[passIndex] });

  const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    vertex: { module: vertexModule, entryPoint: "main" },
    fragment: { module: fragmentModule, entryPoint: "main", targets: [{ format }] },
    primitive: { topology: "triangle-list", cullMode: "none" },
  });

  const samplers: Record<string, GPUSampler> = {};
  const textureViews: Record<string, GPUTextureView> = {};
  for (const name of TransformTextureNames) {
    samplers[name] = device.createSampler({ magFilter: "linear", minFilter: "linear" });
    const placeholder = device.createTexture({ size: { width: 1, height: 1 }, format, usage: GPUTextureUsage.TEXTURE_BINDING });
    textureViews[name] = placeholder.createView();
  }

  let bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: textureViews['src'] },
      { binding: 2, resource: samplers['src'] },
    ],
  });

  const rebuildBindGroup = () => {
    bindGroup = device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: textureViews['src'] },
        { binding: 2, resource: samplers['src'] },
      ],
    });
  };

  const handles: TransformMaterialHandles = {
    pipeline,
    get bindGroup() { return bindGroup; },
    setTexture: (name, texture) => {
      textureViews[name] = texture;
      rebuildBindGroup();
    },
    setUniforms: (updates) => {
      currentUniforms = { ...currentUniforms, ...updates };
      packTransformUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
      device.queue.writeBuffer(uniformBuffer, 0, uniformData);
    },
  };

  return handles;
}

export class TransformEffect extends CustomShaderEffect<TransformUniforms, TransformInputs> {
  override effectName = 'Transform';

  constructor(device: GPUDevice, inputs: TransformInputs, width = 1280, height = 720, format: GPUTextureFormat = 'rgba16float', clearColor: GPUColor = { r: 0, g: 0, b: 0, a: 1 }) {
    super(device, inputs, {
      factory: (deviceRef, formatRef, options) => createTransformMaterial(deviceRef, formatRef, options),
      textureInputKeys: ['src'],
      textureBindingKeys: TransformTextureNames,
      passTextureSources: TransformPassTextureSources,
      passCount: 1,
      primaryTextureKey: 'src',
      width,
      height,
      format,
      clearColor,
      uniformMeta: TransformUniformMeta,
    });
    this.setUniforms({ rotate: 0, anchor: [0.5, 0.5], translate: [0, 0], scale: [1, 1] });
  }

  override setUniforms(uniforms: { rotate?: Dynamic<number>, anchor?: Dynamic<readonly [number, number]>, translate?: Dynamic<readonly [number, number]>, scale?: Dynamic<readonly [number, number]> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.rotate !== undefined) {
      record['rotate'] = uniforms.rotate;
    }
    if (uniforms.anchor !== undefined) {
      record['anchor'] = uniforms.anchor;
    }
    if (uniforms.translate !== undefined) {
      record['translate'] = uniforms.translate;
    }
    if (uniforms.scale !== undefined) {
      record['scale'] = uniforms.scale;
    }
    super.setUniforms(record);
  }
}

