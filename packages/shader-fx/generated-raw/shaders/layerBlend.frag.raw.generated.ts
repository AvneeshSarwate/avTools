// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
import { CustomShaderEffect, type ShaderSource, type UniformDescriptor, type MaterialHandles } from '@avtools/shader-fx/raw';
export const LayerBlendVertexSource = `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) vUV: vec2f,
};

@vertex
fn main(@builtin(vertex_index) index: u32) -> VertexOutput {
  var positions = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f(3.0, -1.0),
    vec2f(-1.0, 3.0),
  );
  var uvs = array<vec2f, 3>(
    vec2f(0.0, 1.0),
    vec2f(2.0, 1.0),
    vec2f(0.0, -1.0),
  );
  var out: VertexOutput;
  out.position = vec4f(positions[index], 0.0, 1.0);
  out.vUV = uvs[index];
  return out;
}

`;
export const LayerBlendFragmentSources = [
  `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
fn pass0(uv: vec2f, src1: texture_2d<f32>, src1Sampler: sampler, src2: texture_2d<f32>, src2Sampler: sampler) -> vec4f {
  let color1 = textureSample(src1, src1Sampler, uv);
  let color2 = textureSample(src2, src2Sampler, uv);
  let returnColor = select(color2, color1, color1.a > 0.01);
  return returnColor;
}

@group(0) @binding(0) var src1: texture_2d<f32>;
@group(0) @binding(1) var src1Sampler: sampler;
@group(0) @binding(2) var src2: texture_2d<f32>;
@group(0) @binding(3) var src2Sampler: sampler;

struct FragmentInput {
  @location(0) vUV: vec2f,
};

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  let uv_local = input.vUV;
  let color = pass0(uv_local, src1, src1Sampler, src2, src2Sampler);
  return color;
}

`, // pass0
] as const;
export const LayerBlendPassCount = 1 as const;
export const LayerBlendPrimaryTextureName = 'src1' as const;

export const LayerBlendPassTextureSources = [
  [
    { binding: 'src1', source: { kind: 'input', key: 'src1' } },
    { binding: 'src2', source: { kind: 'input', key: 'src2' } },
  ],
] as const;

export const LayerBlendUniformMeta: UniformDescriptor[] = [];

export type LayerBlendUniforms = Record<string, never>;
export const LayerBlendUniformsDefaults = {};

export type LayerBlendTextureName = 'src1' | 'src2';
export const LayerBlendTextureNames = ['src1', 'src2'] as const;
export interface LayerBlendInputs {
  src1: ShaderSource;
  src2: ShaderSource;
}

export type LayerBlendMaterialHandles = MaterialHandles<LayerBlendUniforms, LayerBlendTextureName>;

export interface LayerBlendMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createLayerBlendMaterial(device: GPUDevice, format: GPUTextureFormat, options: LayerBlendMaterialOptions = {}): LayerBlendMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 1) {
    throw new Error(`Invalid passIndex ${passIndex} for LayerBlend. Expected 0 <= passIndex < 1.`);
  }
  const bindGroupLayout = device.createBindGroupLayout({ entries: [
    { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
    { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
  ] });

  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
  const vertexModule = device.createShaderModule({ code: LayerBlendVertexSource });
  const fragmentModule = device.createShaderModule({ code: LayerBlendFragmentSources[passIndex] });

  const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    vertex: { module: vertexModule, entryPoint: "main" },
    fragment: { module: fragmentModule, entryPoint: "main", targets: [{ format }] },
    primitive: { topology: "triangle-list", cullMode: "none" },
  });

  const samplers: Record<string, GPUSampler> = {};
  const textureViews: Record<string, GPUTextureView> = {};
  for (const name of LayerBlendTextureNames) {
    samplers[name] = device.createSampler({ magFilter: "linear", minFilter: "linear" });
    const placeholder = device.createTexture({ size: { width: 1, height: 1 }, format, usage: GPUTextureUsage.TEXTURE_BINDING });
    textureViews[name] = placeholder.createView();
  }

  let bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: textureViews['src1'] },
      { binding: 1, resource: samplers['src1'] },
      { binding: 2, resource: textureViews['src2'] },
      { binding: 3, resource: samplers['src2'] },
    ],
  });

  const rebuildBindGroup = () => {
    bindGroup = device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: textureViews['src1'] },
        { binding: 1, resource: samplers['src1'] },
        { binding: 2, resource: textureViews['src2'] },
        { binding: 3, resource: samplers['src2'] },
      ],
    });
  };

  const handles: LayerBlendMaterialHandles = {
    pipeline,
    get bindGroup() { return bindGroup; },
    setTexture: (name, texture) => {
      textureViews[name] = texture;
      rebuildBindGroup();
    },
    setUniforms: () => {},
  };

  return handles;
}

export class LayerBlendEffect extends CustomShaderEffect<LayerBlendUniforms, LayerBlendInputs> {
  override effectName = 'LayerBlend';

  constructor(device: GPUDevice, inputs: LayerBlendInputs, width = 1280, height = 720, format: GPUTextureFormat = 'rgba16float', clearColor: GPUColor = { r: 0, g: 0, b: 0, a: 1 }) {
    super(device, inputs, {
      factory: (deviceRef, formatRef, options) => createLayerBlendMaterial(deviceRef, formatRef, options),
      textureInputKeys: ['src1', 'src2'],
      textureBindingKeys: LayerBlendTextureNames,
      passTextureSources: LayerBlendPassTextureSources,
      passCount: 1,
      primaryTextureKey: 'src1',
      width,
      height,
      format,
      clearColor,
      uniformMeta: LayerBlendUniformMeta,
    });
  }
}

