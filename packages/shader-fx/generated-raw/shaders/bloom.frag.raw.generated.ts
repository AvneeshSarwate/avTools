// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
import { CustomShaderEffect, type ShaderSource, type UniformDescriptor, type MaterialHandles, type ShaderUniforms, type Dynamic } from '@avtools/shader-fx/raw';
export const BloomVertexSource = `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) vUV: vec2f,
};

@vertex
fn main(@builtin(vertex_index) index: u32) -> VertexOutput {
  var positions = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f(3.0, -1.0),
    vec2f(-1.0, 3.0),
  );
  var uvs = array<vec2f, 3>(
    vec2f(0.0, 1.0),
    vec2f(2.0, 1.0),
    vec2f(0.0, -1.0),
  );
  var out: VertexOutput;
  out.position = vec4f(positions[index], 0.0, 1.0);
  out.vUV = uvs[index];
  return out;
}

`;
export const BloomFragmentSources = [
  `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct BloomUniforms {
  preBlackLevel: f32, // 0.05
  preGamma: f32, // 1.0
  preBrightness: f32, // 2.0
  minBloomRadius: f32, // 0.1
  maxBloomRadius: f32, // 0.6
  bloomThreshold: f32, // 0.12
  bloomSCurve: f32, // 0.35
  bloomFill: f32, // 0.25
  bloomIntensity: f32, // 1.1
  outputMode: u32, // 0
  inputImage: f32, // 1.0
};

fn saturateVec3(value: vec3f) -> vec3f {
  return clamp(value, vec3f(0.0), vec3f(1.0));
}

fn saturateScalar(value: f32) -> f32 {
  return clamp(value, 0.0, 1.0);
}

fn applyPreprocess(color: vec3f, uniforms: BloomUniforms) -> vec3f {
  var isolated = max(color - vec3f(uniforms.preBlackLevel), vec3f(0.0));
  isolated = isolated * uniforms.preBrightness;
  let gamma = max(uniforms.preGamma, 1e-6);
  let invGamma = 1.0 / gamma;
  isolated = pow(max(isolated, vec3f(0.0)), vec3f(invGamma));
  return saturateVec3(isolated);
}

fn applyThreshold(value: vec3f, threshold: f32) -> vec3f {
  return max(value - vec3f(threshold), vec3f(0.0));
}

fn applySCurve(value: vec3f, amount: f32) -> vec3f {
  let t = saturateScalar(amount);
  if (t <= 0.0) {
    return value;
  }
  let smoothVal = value * value * (3.0 - 2.0 * value);
  return mix(value, smoothVal, vec3f(t));
}

fn computeRadiusUv(radiusNorm: f32, fill: f32, texelSize: vec2f) -> vec2f {
  let safeNorm = saturateScalar(radiusNorm);
  let spread = 1.0 + fill * 6.0;
  let radiusPixels = (1.0 + safeNorm * 6.0) * spread;
  return radiusPixels * texelSize;
}

fn pass0(uv: vec2f, uniforms: BloomUniforms, src: texture_2d<f32>, srcSampler: sampler) -> vec4f {
  let baseColor = textureSample(src, srcSampler, uv);
  let processed = applyPreprocess(baseColor.rgb, uniforms);
  let alpha = max(max(processed.r, processed.g), processed.b);
  return vec4f(processed, alpha);
}

fn pass1(
  uv: vec2f,
  uniforms: BloomUniforms,
  src: texture_2d<f32>,
  srcSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
) -> vec4f {
  let baseColor = textureSample(src, srcSampler, uv);
  let preColor = textureSample(pass0Texture, pass0Sampler, uv).rgb;

  let dims = textureDimensions(pass0Texture);
  let texelSize = vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
  let minRadius = min(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  let maxRadius = max(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  var accum = preColor;
  var totalWeight = 1.0;
  let levelCount = 6;
  for (var level = 0; level < levelCount; level = level + 1) {
    let t = f32(level + 1) / f32(levelCount);
    let radiusNorm = mix(minRadius, maxRadius, t);
    let offsetScale = computeRadiusUv(radiusNorm, uniforms.bloomFill, texelSize);
    let weightBase = 1.0 / (1.0 + radiusNorm * 8.0 + uniforms.bloomFill * 4.0);
    for (var i = 0; i < 8; i = i + 1) {
      var direction = vec2f(1.0, 0.0);
      switch u32(i) {
        case 0u: {
          direction = vec2f(1.0, 0.0);
        }
        case 1u: {
          direction = vec2f(-1.0, 0.0);
        }
        case 2u: {
          direction = vec2f(0.0, 1.0);
        }
        case 3u: {
          direction = vec2f(0.0, -1.0);
        }
        case 4u: {
          direction = vec2f(0.7071, 0.7071);
        }
        case 5u: {
          direction = vec2f(-0.7071, 0.7071);
        }
        case 6u: {
          direction = vec2f(0.7071, -0.7071);
        }
        default: {
          direction = vec2f(-0.7071, -0.7071);
        }
      }
      let offsetUV = uv + direction * offsetScale;
      let sampleColor = textureSample(pass0Texture, pass0Sampler, offsetUV).rgb;
      accum = accum + sampleColor * weightBase;
      totalWeight = totalWeight + weightBase;
    }
  }

  var bloom = accum / max(totalWeight, 1e-5);
  bloom = applyThreshold(bloom, uniforms.bloomThreshold);
  bloom = applySCurve(bloom, uniforms.bloomSCurve);
  bloom = bloom * uniforms.bloomIntensity;
  bloom = saturateVec3(bloom);

  let outputMode = uniforms.outputMode;
  let inputContribution = baseColor.rgb * uniforms.inputImage;

  let bloomAlpha = max(max(bloom.r, bloom.g), bloom.b);
  var finalColor = vec3f(0.0);
  var finalAlpha = baseColor.a;

  switch outputMode {
    case 1u: { // Input only
      finalColor = inputContribution;
      finalAlpha = baseColor.a;
    }
    case 2u: { // Preprocess preview
      finalColor = preColor;
      finalAlpha = 1.0;
    }
    case 3u: { // Bloom only
      finalColor = bloom;
      finalAlpha = 1.0;
    }
    case 4u: { // Bloom with alpha
      finalColor = bloom;
      finalAlpha = bloomAlpha;
    }
    default: { // Input + Bloom
      finalColor = saturateVec3(inputContribution + bloom);
      finalAlpha = baseColor.a;
    }
  }

  return vec4f(finalColor, finalAlpha);
}

@group(0) @binding(0) var<uniform> uniforms: BloomUniforms;
@group(0) @binding(1) var src: texture_2d<f32>;
@group(0) @binding(2) var srcSampler: sampler;
@group(0) @binding(3) var pass0Texture: texture_2d<f32>;
@group(0) @binding(4) var pass0Sampler: sampler;

struct FragmentInput {
  @location(0) vUV: vec2f,
};

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  let uv_local = input.vUV;
  let uniforms_value = uniforms;
  let color = pass0(uv_local, uniforms_value, src, srcSampler);
  return color;
}

`, // pass0
  `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct BloomUniforms {
  preBlackLevel: f32, // 0.05
  preGamma: f32, // 1.0
  preBrightness: f32, // 2.0
  minBloomRadius: f32, // 0.1
  maxBloomRadius: f32, // 0.6
  bloomThreshold: f32, // 0.12
  bloomSCurve: f32, // 0.35
  bloomFill: f32, // 0.25
  bloomIntensity: f32, // 1.1
  outputMode: u32, // 0
  inputImage: f32, // 1.0
};

fn saturateVec3(value: vec3f) -> vec3f {
  return clamp(value, vec3f(0.0), vec3f(1.0));
}

fn saturateScalar(value: f32) -> f32 {
  return clamp(value, 0.0, 1.0);
}

fn applyPreprocess(color: vec3f, uniforms: BloomUniforms) -> vec3f {
  var isolated = max(color - vec3f(uniforms.preBlackLevel), vec3f(0.0));
  isolated = isolated * uniforms.preBrightness;
  let gamma = max(uniforms.preGamma, 1e-6);
  let invGamma = 1.0 / gamma;
  isolated = pow(max(isolated, vec3f(0.0)), vec3f(invGamma));
  return saturateVec3(isolated);
}

fn applyThreshold(value: vec3f, threshold: f32) -> vec3f {
  return max(value - vec3f(threshold), vec3f(0.0));
}

fn applySCurve(value: vec3f, amount: f32) -> vec3f {
  let t = saturateScalar(amount);
  if (t <= 0.0) {
    return value;
  }
  let smoothVal = value * value * (3.0 - 2.0 * value);
  return mix(value, smoothVal, vec3f(t));
}

fn computeRadiusUv(radiusNorm: f32, fill: f32, texelSize: vec2f) -> vec2f {
  let safeNorm = saturateScalar(radiusNorm);
  let spread = 1.0 + fill * 6.0;
  let radiusPixels = (1.0 + safeNorm * 6.0) * spread;
  return radiusPixels * texelSize;
}

fn pass0(uv: vec2f, uniforms: BloomUniforms, src: texture_2d<f32>, srcSampler: sampler) -> vec4f {
  let baseColor = textureSample(src, srcSampler, uv);
  let processed = applyPreprocess(baseColor.rgb, uniforms);
  let alpha = max(max(processed.r, processed.g), processed.b);
  return vec4f(processed, alpha);
}

fn pass1(
  uv: vec2f,
  uniforms: BloomUniforms,
  src: texture_2d<f32>,
  srcSampler: sampler,
  pass0Texture: texture_2d<f32>,
  pass0Sampler: sampler,
) -> vec4f {
  let baseColor = textureSample(src, srcSampler, uv);
  let preColor = textureSample(pass0Texture, pass0Sampler, uv).rgb;

  let dims = textureDimensions(pass0Texture);
  let texelSize = vec2f(
    select(1.0 / f32(dims.x), 0.0, dims.x == 0u),
    select(1.0 / f32(dims.y), 0.0, dims.y == 0u),
  );
  let minRadius = min(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  let maxRadius = max(uniforms.minBloomRadius, uniforms.maxBloomRadius);
  var accum = preColor;
  var totalWeight = 1.0;
  let levelCount = 6;
  for (var level = 0; level < levelCount; level = level + 1) {
    let t = f32(level + 1) / f32(levelCount);
    let radiusNorm = mix(minRadius, maxRadius, t);
    let offsetScale = computeRadiusUv(radiusNorm, uniforms.bloomFill, texelSize);
    let weightBase = 1.0 / (1.0 + radiusNorm * 8.0 + uniforms.bloomFill * 4.0);
    for (var i = 0; i < 8; i = i + 1) {
      var direction = vec2f(1.0, 0.0);
      switch u32(i) {
        case 0u: {
          direction = vec2f(1.0, 0.0);
        }
        case 1u: {
          direction = vec2f(-1.0, 0.0);
        }
        case 2u: {
          direction = vec2f(0.0, 1.0);
        }
        case 3u: {
          direction = vec2f(0.0, -1.0);
        }
        case 4u: {
          direction = vec2f(0.7071, 0.7071);
        }
        case 5u: {
          direction = vec2f(-0.7071, 0.7071);
        }
        case 6u: {
          direction = vec2f(0.7071, -0.7071);
        }
        default: {
          direction = vec2f(-0.7071, -0.7071);
        }
      }
      let offsetUV = uv + direction * offsetScale;
      let sampleColor = textureSample(pass0Texture, pass0Sampler, offsetUV).rgb;
      accum = accum + sampleColor * weightBase;
      totalWeight = totalWeight + weightBase;
    }
  }

  var bloom = accum / max(totalWeight, 1e-5);
  bloom = applyThreshold(bloom, uniforms.bloomThreshold);
  bloom = applySCurve(bloom, uniforms.bloomSCurve);
  bloom = bloom * uniforms.bloomIntensity;
  bloom = saturateVec3(bloom);

  let outputMode = uniforms.outputMode;
  let inputContribution = baseColor.rgb * uniforms.inputImage;

  let bloomAlpha = max(max(bloom.r, bloom.g), bloom.b);
  var finalColor = vec3f(0.0);
  var finalAlpha = baseColor.a;

  switch outputMode {
    case 1u: { // Input only
      finalColor = inputContribution;
      finalAlpha = baseColor.a;
    }
    case 2u: { // Preprocess preview
      finalColor = preColor;
      finalAlpha = 1.0;
    }
    case 3u: { // Bloom only
      finalColor = bloom;
      finalAlpha = 1.0;
    }
    case 4u: { // Bloom with alpha
      finalColor = bloom;
      finalAlpha = bloomAlpha;
    }
    default: { // Input + Bloom
      finalColor = saturateVec3(inputContribution + bloom);
      finalAlpha = baseColor.a;
    }
  }

  return vec4f(finalColor, finalAlpha);
}

@group(0) @binding(0) var<uniform> uniforms: BloomUniforms;
@group(0) @binding(1) var src: texture_2d<f32>;
@group(0) @binding(2) var srcSampler: sampler;
@group(0) @binding(3) var pass0Texture: texture_2d<f32>;
@group(0) @binding(4) var pass0Sampler: sampler;

struct FragmentInput {
  @location(0) vUV: vec2f,
};

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  let uv_local = input.vUV;
  let uniforms_value = uniforms;
  let color = pass1(uv_local, uniforms_value, src, srcSampler, pass0Texture, pass0Sampler);
  return color;
}

`, // pass1
] as const;
export const BloomPassCount = 2 as const;
export const BloomPrimaryTextureName = 'src' as const;

export const BloomPassTextureSources = [
  [
    { binding: 'src', source: { kind: 'input', key: 'src' } },
  ],
  [
    { binding: 'src', source: { kind: 'input', key: 'src' } },
    { binding: 'pass0Texture', source: { kind: 'pass', passIndex: 0 } },
  ],
] as const;

export const BloomUniformMeta: UniformDescriptor[] = [
  {
    name: 'preBlackLevel',
    kind: 'f32',
    bindingName: 'uniforms_preBlackLevel',
    default: 0.05,
  },
  {
    name: 'preGamma',
    kind: 'f32',
    bindingName: 'uniforms_preGamma',
    default: 1.0,
  },
  {
    name: 'preBrightness',
    kind: 'f32',
    bindingName: 'uniforms_preBrightness',
    default: 2.0,
  },
  {
    name: 'minBloomRadius',
    kind: 'f32',
    bindingName: 'uniforms_minBloomRadius',
    default: 0.1,
  },
  {
    name: 'maxBloomRadius',
    kind: 'f32',
    bindingName: 'uniforms_maxBloomRadius',
    default: 0.6,
  },
  {
    name: 'bloomThreshold',
    kind: 'f32',
    bindingName: 'uniforms_bloomThreshold',
    default: 0.12,
  },
  {
    name: 'bloomSCurve',
    kind: 'f32',
    bindingName: 'uniforms_bloomSCurve',
    default: 0.35,
  },
  {
    name: 'bloomFill',
    kind: 'f32',
    bindingName: 'uniforms_bloomFill',
    default: 0.25,
  },
  {
    name: 'bloomIntensity',
    kind: 'f32',
    bindingName: 'uniforms_bloomIntensity',
    default: 1.1,
  },
  {
    name: 'outputMode',
    kind: 'u32',
    bindingName: 'uniforms_outputMode',
    default: 0,
  },
  {
    name: 'inputImage',
    kind: 'f32',
    bindingName: 'uniforms_inputImage',
    default: 1.0,
  },
];

export interface BloomUniforms {
  preBlackLevel: number;
  preGamma: number;
  preBrightness: number;
  minBloomRadius: number;
  maxBloomRadius: number;
  bloomThreshold: number;
  bloomSCurve: number;
  bloomFill: number;
  bloomIntensity: number;
  outputMode: number;
  inputImage: number;
}

export const BloomUniformsDefaults: BloomUniforms = {
  preBlackLevel: 0,
  preGamma: 0,
  preBrightness: 0,
  minBloomRadius: 0,
  maxBloomRadius: 0,
  bloomThreshold: 0,
  bloomSCurve: 0,
  bloomFill: 0,
  bloomIntensity: 0,
  outputMode: 0,
  inputImage: 0,
};

const BloomUniformsLayoutSize = 44;

function packBloomUniforms(floatView: Float32Array, intView: Int32Array, uintView: Uint32Array, floatOffset: number, value: BloomUniforms): void {
  {
    const base = floatOffset + 0;
    const raw = value.preBlackLevel;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 1;
    const raw = value.preGamma;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 2;
    const raw = value.preBrightness;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 3;
    const raw = value.minBloomRadius;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 4;
    const raw = value.maxBloomRadius;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 5;
    const raw = value.bloomThreshold;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 6;
    const raw = value.bloomSCurve;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 7;
    const raw = value.bloomFill;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 8;
    const raw = value.bloomIntensity;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
  {
    const base = floatOffset + 9;
    const raw = value.outputMode;
    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;
  }
  {
    const base = floatOffset + 10;
    const raw = value.inputImage;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
}

export type BloomTextureName = 'src' | 'pass0Texture';
export const BloomTextureNames = ['src', 'pass0Texture'] as const;
export interface BloomInputs {
  src: ShaderSource;
}

export type BloomMaterialHandles = MaterialHandles<BloomUniforms, BloomTextureName>;

export interface BloomMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createBloomMaterial(device: GPUDevice, format: GPUTextureFormat, options: BloomMaterialOptions = {}): BloomMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 2) {
    throw new Error(`Invalid passIndex ${passIndex} for Bloom. Expected 0 <= passIndex < 2.`);
  }
  const uniformData = new ArrayBuffer(BloomUniformsLayoutSize);
  const uniformFloats = new Float32Array(uniformData);
  const uniformInts = new Int32Array(uniformData);
  const uniformUints = new Uint32Array(uniformData);
  let currentUniforms: BloomUniforms = { ...BloomUniformsDefaults };
  packBloomUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
  const uniformBuffer = device.createBuffer({ size: uniformData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);

  const bindGroupLayout = device.createBindGroupLayout({ entries: [
    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
    { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 4, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
  ] });

  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
  const vertexModule = device.createShaderModule({ code: BloomVertexSource });
  const fragmentModule = device.createShaderModule({ code: BloomFragmentSources[passIndex] });

  const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    vertex: { module: vertexModule, entryPoint: "main" },
    fragment: { module: fragmentModule, entryPoint: "main", targets: [{ format }] },
    primitive: { topology: "triangle-list", cullMode: "none" },
  });

  const samplers: Record<string, GPUSampler> = {};
  const textureViews: Record<string, GPUTextureView> = {};
  for (const name of BloomTextureNames) {
    samplers[name] = device.createSampler({ magFilter: "linear", minFilter: "linear" });
    const placeholder = device.createTexture({ size: { width: 1, height: 1 }, format, usage: GPUTextureUsage.TEXTURE_BINDING });
    textureViews[name] = placeholder.createView();
  }

  let bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: textureViews['src'] },
      { binding: 2, resource: samplers['src'] },
      { binding: 3, resource: textureViews['pass0Texture'] },
      { binding: 4, resource: samplers['pass0Texture'] },
    ],
  });

  const rebuildBindGroup = () => {
    bindGroup = device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: textureViews['src'] },
        { binding: 2, resource: samplers['src'] },
        { binding: 3, resource: textureViews['pass0Texture'] },
        { binding: 4, resource: samplers['pass0Texture'] },
      ],
    });
  };

  const handles: BloomMaterialHandles = {
    pipeline,
    get bindGroup() { return bindGroup; },
    setTexture: (name, texture) => {
      textureViews[name] = texture;
      rebuildBindGroup();
    },
    setUniforms: (updates) => {
      currentUniforms = { ...currentUniforms, ...updates };
      packBloomUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
      device.queue.writeBuffer(uniformBuffer, 0, uniformData);
    },
  };

  return handles;
}

export class BloomEffect extends CustomShaderEffect<BloomUniforms, BloomInputs> {
  override effectName = 'Bloom';

  constructor(device: GPUDevice, inputs: BloomInputs, width = 1280, height = 720, format: GPUTextureFormat = 'rgba16float', clearColor: GPUColor = { r: 0, g: 0, b: 0, a: 1 }) {
    super(device, inputs, {
      factory: (deviceRef, formatRef, options) => createBloomMaterial(deviceRef, formatRef, options),
      textureInputKeys: ['src'],
      textureBindingKeys: BloomTextureNames,
      passTextureSources: BloomPassTextureSources,
      passCount: 2,
      primaryTextureKey: 'src',
      width,
      height,
      format,
      clearColor,
      uniformMeta: BloomUniformMeta,
    });
    this.setUniforms({
      preBlackLevel: 0.05,
      preGamma: 1.0,
      preBrightness: 2.0,
      minBloomRadius: 0.1,
      maxBloomRadius: 0.6,
      bloomThreshold: 0.12,
      bloomSCurve: 0.35,
      bloomFill: 0.25,
      bloomIntensity: 1.1,
      outputMode: 0,
      inputImage: 1.0,
    });
  }

  override setUniforms(uniforms: { preBlackLevel?: Dynamic<number>, preGamma?: Dynamic<number>, preBrightness?: Dynamic<number>, minBloomRadius?: Dynamic<number>, maxBloomRadius?: Dynamic<number>, bloomThreshold?: Dynamic<number>, bloomSCurve?: Dynamic<number>, bloomFill?: Dynamic<number>, bloomIntensity?: Dynamic<number>, outputMode?: Dynamic<number>, inputImage?: Dynamic<number> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.preBlackLevel !== undefined) {
      record['preBlackLevel'] = uniforms.preBlackLevel;
    }
    if (uniforms.preGamma !== undefined) {
      record['preGamma'] = uniforms.preGamma;
    }
    if (uniforms.preBrightness !== undefined) {
      record['preBrightness'] = uniforms.preBrightness;
    }
    if (uniforms.minBloomRadius !== undefined) {
      record['minBloomRadius'] = uniforms.minBloomRadius;
    }
    if (uniforms.maxBloomRadius !== undefined) {
      record['maxBloomRadius'] = uniforms.maxBloomRadius;
    }
    if (uniforms.bloomThreshold !== undefined) {
      record['bloomThreshold'] = uniforms.bloomThreshold;
    }
    if (uniforms.bloomSCurve !== undefined) {
      record['bloomSCurve'] = uniforms.bloomSCurve;
    }
    if (uniforms.bloomFill !== undefined) {
      record['bloomFill'] = uniforms.bloomFill;
    }
    if (uniforms.bloomIntensity !== undefined) {
      record['bloomIntensity'] = uniforms.bloomIntensity;
    }
    if (uniforms.outputMode !== undefined) {
      record['outputMode'] = uniforms.outputMode;
    }
    if (uniforms.inputImage !== undefined) {
      record['inputImage'] = uniforms.inputImage;
    }
    super.setUniforms(record);
  }
}

