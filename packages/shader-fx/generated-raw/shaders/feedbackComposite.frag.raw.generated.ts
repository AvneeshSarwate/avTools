// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
import { CustomShaderEffect, type ShaderSource, type UniformDescriptor, type MaterialHandles, type ShaderUniforms, type Dynamic } from '@avtools/shader-fx/raw';
export const FeedbackCompositeVertexSource = `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) vUV: vec2f,
};

@vertex
fn main(@builtin(vertex_index) index: u32) -> VertexOutput {
  var positions = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f(3.0, -1.0),
    vec2f(-1.0, 3.0),
  );
  var uvs = array<vec2f, 3>(
    vec2f(0.0, 1.0),
    vec2f(2.0, 1.0),
    vec2f(0.0, -1.0),
  );
  var out: VertexOutput;
  out.position = vec4f(positions[index], 0.0, 1.0);
  out.vUV = uvs[index];
  return out;
}

`;
export const FeedbackCompositeFragmentSources = [
  `// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.
struct FeedbackUniforms {
  translate: vec2f,
  decay: f32,
};

fn pass0(
  uv: vec2f,
  uniforms: FeedbackUniforms,
  src: texture_2d<f32>,
  srcSampler: sampler,
  feedback: texture_2d<f32>,
  feedbackSampler: sampler,
) -> vec4f {
  let current = textureSample(src, srcSampler, uv);
  let prev = textureSample(feedback, feedbackSampler, uv - uniforms.translate);
  let blended = max(current, prev * uniforms.decay);
  return vec4f(blended.rgb, 1.0);
}

@group(0) @binding(0) var<uniform> uniforms: FeedbackUniforms;
@group(0) @binding(1) var src: texture_2d<f32>;
@group(0) @binding(2) var srcSampler: sampler;
@group(0) @binding(3) var feedback: texture_2d<f32>;
@group(0) @binding(4) var feedbackSampler: sampler;

struct FragmentInput {
  @location(0) vUV: vec2f,
};

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  let uv_local = input.vUV;
  let uniforms_value = uniforms;
  let color = pass0(uv_local, uniforms_value, src, srcSampler, feedback, feedbackSampler);
  return color;
}

`, // pass0
] as const;
export const FeedbackCompositePassCount = 1 as const;
export const FeedbackCompositePrimaryTextureName = 'src' as const;

export const FeedbackCompositePassTextureSources = [
  [
    { binding: 'src', source: { kind: 'input', key: 'src' } },
    { binding: 'feedback', source: { kind: 'input', key: 'feedback' } },
  ],
] as const;

export const FeedbackCompositeUniformMeta: UniformDescriptor[] = [
  {
    name: 'translate',
    kind: 'vec2f',
    bindingName: 'uniforms_translate',
  },
  {
    name: 'decay',
    kind: 'f32',
    bindingName: 'uniforms_decay',
  },
];

export interface FeedbackCompositeFeedbackUniforms {
  translate: readonly [number, number];
  decay: number;
}

export const FeedbackCompositeFeedbackUniformsDefaults: FeedbackCompositeFeedbackUniforms = {
  translate: [0, 0],
  decay: 0,
};

const FeedbackUniformsLayoutSize = 16;

function packFeedbackUniforms(floatView: Float32Array, intView: Int32Array, uintView: Uint32Array, floatOffset: number, value: FeedbackCompositeFeedbackUniforms): void {
  {
    const base = floatOffset + 0;
    const value_translate = value.translate as any;
    for (let i = 0; i < 2; i++) {
      const component = value_translate?.[i];
      floatView[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
  {
    const base = floatOffset + 2;
    const raw = value.decay;
    floatView[base] = raw !== undefined ? Number(raw) : 0;
  }
}

export type FeedbackCompositeTextureName = 'src' | 'feedback';
export const FeedbackCompositeTextureNames = ['src', 'feedback'] as const;
export interface FeedbackCompositeInputs {
  src: ShaderSource;
  feedback: ShaderSource;
}

export type FeedbackCompositeMaterialHandles = MaterialHandles<FeedbackCompositeFeedbackUniforms, FeedbackCompositeTextureName>;

export interface FeedbackCompositeMaterialOptions {
  name?: string;
  passIndex?: number;
}

export function createFeedbackCompositeMaterial(device: GPUDevice, format: GPUTextureFormat, options: FeedbackCompositeMaterialOptions = {}): FeedbackCompositeMaterialHandles {
  const passIndex = options.passIndex ?? 0;
  if (passIndex < 0 || passIndex >= 1) {
    throw new Error(`Invalid passIndex ${passIndex} for FeedbackComposite. Expected 0 <= passIndex < 1.`);
  }
  const uniformData = new ArrayBuffer(FeedbackUniformsLayoutSize);
  const uniformFloats = new Float32Array(uniformData);
  const uniformInts = new Int32Array(uniformData);
  const uniformUints = new Uint32Array(uniformData);
  let currentUniforms: FeedbackCompositeFeedbackUniforms = { ...FeedbackCompositeFeedbackUniformsDefaults };
  packFeedbackUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
  const uniformBuffer = device.createBuffer({ size: uniformData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);

  const bindGroupLayout = device.createBindGroupLayout({ entries: [
    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
    { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 4, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
  ] });

  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
  const vertexModule = device.createShaderModule({ code: FeedbackCompositeVertexSource });
  const fragmentModule = device.createShaderModule({ code: FeedbackCompositeFragmentSources[passIndex] });

  const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    vertex: { module: vertexModule, entryPoint: "main" },
    fragment: { module: fragmentModule, entryPoint: "main", targets: [{ format }] },
    primitive: { topology: "triangle-list", cullMode: "none" },
  });

  const samplers: Record<string, GPUSampler> = {};
  const textureViews: Record<string, GPUTextureView> = {};
  for (const name of FeedbackCompositeTextureNames) {
    samplers[name] = device.createSampler({ magFilter: "linear", minFilter: "linear" });
    const placeholder = device.createTexture({ size: { width: 1, height: 1 }, format, usage: GPUTextureUsage.TEXTURE_BINDING });
    textureViews[name] = placeholder.createView();
  }

  let bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: textureViews['src'] },
      { binding: 2, resource: samplers['src'] },
      { binding: 3, resource: textureViews['feedback'] },
      { binding: 4, resource: samplers['feedback'] },
    ],
  });

  const rebuildBindGroup = () => {
    bindGroup = device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: textureViews['src'] },
        { binding: 2, resource: samplers['src'] },
        { binding: 3, resource: textureViews['feedback'] },
        { binding: 4, resource: samplers['feedback'] },
      ],
    });
  };

  const handles: FeedbackCompositeMaterialHandles = {
    pipeline,
    get bindGroup() { return bindGroup; },
    setTexture: (name, texture) => {
      textureViews[name] = texture;
      rebuildBindGroup();
    },
    setUniforms: (updates) => {
      currentUniforms = { ...currentUniforms, ...updates };
      packFeedbackUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
      device.queue.writeBuffer(uniformBuffer, 0, uniformData);
    },
  };

  return handles;
}

export class FeedbackCompositeEffect extends CustomShaderEffect<FeedbackCompositeFeedbackUniforms, FeedbackCompositeInputs> {
  override effectName = 'FeedbackComposite';

  constructor(device: GPUDevice, inputs: FeedbackCompositeInputs, width = 1280, height = 720, format: GPUTextureFormat = 'rgba16float', clearColor: GPUColor = { r: 0, g: 0, b: 0, a: 1 }) {
    super(device, inputs, {
      factory: (deviceRef, formatRef, options) => createFeedbackCompositeMaterial(deviceRef, formatRef, options),
      textureInputKeys: ['src', 'feedback'],
      textureBindingKeys: FeedbackCompositeTextureNames,
      passTextureSources: FeedbackCompositePassTextureSources,
      passCount: 1,
      primaryTextureKey: 'src',
      width,
      height,
      format,
      clearColor,
      uniformMeta: FeedbackCompositeUniformMeta,
    });
  }

  override setUniforms(uniforms: { translate?: Dynamic<readonly [number, number]>, decay?: Dynamic<number> }): void {
    const record: ShaderUniforms = {};
    if (uniforms.translate !== undefined) {
      record['translate'] = uniforms.translate;
    }
    if (uniforms.decay !== undefined) {
      record['decay'] = uniforms.decay;
    }
    super.setUniforms(record);
  }
}

