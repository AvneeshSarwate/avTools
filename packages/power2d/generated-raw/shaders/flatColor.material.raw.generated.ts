// Auto-generated by power2d raw material generator. DO NOT EDIT.
import type { MaterialDef, MaterialInstance } from '@avtools/power2d/raw';

export const FlatColorVertexSource = `// Auto-generated by power2d raw material generator. DO NOT EDIT.
@group(0) @binding(0) var<uniform> uniforms: FlatColorUniforms;
struct Power2DBuiltins {
  power2d_shapeTranslate: vec2f,
  power2d_shapeRotation: f32,
  _pad0: f32,
  power2d_shapeScale: vec2f,
  power2d_canvasWidth: f32,
  power2d_canvasHeight: f32,
};
@group(0) @binding(1) var<uniform> power2d: Power2DBuiltins;

struct FlatColorUniforms {
  color: vec4f,
};

fn vertShader(position: vec2f, _uv: vec2f, _uniforms: FlatColorUniforms) -> vec2f {
  return position;
}

fn fragShader(_uv: vec2f, uniforms: FlatColorUniforms) -> vec4f {
  return uniforms.color;
}

struct VertexInput {
  @location(0) position: vec2f,
  @location(1) uv: vec2f,
};
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) vUV: vec2f,
};

fn power2d_applyShapeTransform(pixel: vec2f) -> vec2f {
  let scaled = pixel * power2d.power2d_shapeScale;
  let s = sin(power2d.power2d_shapeRotation);
  let c = cos(power2d.power2d_shapeRotation);
  let rotated = vec2f(
    scaled.x * c - scaled.y * s,
    scaled.x * s + scaled.y * c,
  );
  return rotated + power2d.power2d_shapeTranslate;
}

fn power2d_pixelToNDC(pixel: vec2f) -> vec4f {
  let ndcX = (pixel.x / power2d.power2d_canvasWidth) * 2.0 - 1.0;
  let ndcY = -((pixel.y / power2d.power2d_canvasHeight) * 2.0 - 1.0);
  return vec4f(ndcX, ndcY, 0.0, 1.0);
}

@vertex
fn main(input: VertexInput) -> VertexOutput {
  var out: VertexOutput;
  let pixelPos = input.position;
  let uv = input.uv;
  let adjustedPixelPos = vertShader(pixelPos, uv, uniforms);
  let transformedPixelPos = power2d_applyShapeTransform(adjustedPixelPos);
  out.position = power2d_pixelToNDC(transformedPixelPos);
  out.vUV = uv;
  return out;
}

`;
export const FlatColorFragmentSource = `// Auto-generated by power2d raw material generator. DO NOT EDIT.
@group(0) @binding(0) var<uniform> uniforms: FlatColorUniforms;
struct Power2DBuiltins {
  power2d_shapeTranslate: vec2f,
  power2d_shapeRotation: f32,
  _pad0: f32,
  power2d_shapeScale: vec2f,
  power2d_canvasWidth: f32,
  power2d_canvasHeight: f32,
};
@group(0) @binding(1) var<uniform> power2d: Power2DBuiltins;

struct FlatColorUniforms {
  color: vec4f,
};

fn vertShader(position: vec2f, _uv: vec2f, _uniforms: FlatColorUniforms) -> vec2f {
  return position;
}

fn fragShader(_uv: vec2f, uniforms: FlatColorUniforms) -> vec4f {
  return uniforms.color;
}

struct FragmentInput {
  @location(0) vUV: vec2f,
};

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  let uv = input.vUV;
  return fragShader(uv, uniforms);
}

`;

export interface FlatColorUniforms {
  color: readonly [number, number, number, number];
}

export const FlatColorUniformsDefaults: FlatColorUniforms = {
  color: [0, 0, 0, 0],
};

export type FlatColorTextureName = never;
export const FlatColorTextureNames = [] as const;

const FlatColorUniformsLayoutSize = 16;

function packFlatColorUniforms(floatView: Float32Array, intView: Int32Array, uintView: Uint32Array, floatOffset: number, value: FlatColorUniforms): void {
  {
    const base = floatOffset + 0;
    const colorSource = value.color as any;
    for (let i = 0; i < 4; i++) {
      const component = colorSource?.[i];
      floatView[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
}

export interface FlatColorMaterialInstance extends MaterialInstance<FlatColorUniforms, FlatColorTextureName> {}

export function createFlatColorMaterial(device: GPUDevice, format: GPUTextureFormat, name = 'FlatColorMaterial'): FlatColorMaterialInstance {
  const uniformData = new ArrayBuffer(16);
  const uniformFloats = new Float32Array(uniformData);
  const uniformInts = new Int32Array(uniformData);
  const uniformUints = new Uint32Array(uniformData);
  let currentUniforms: FlatColorUniforms = { ...FlatColorUniformsDefaults };
  packFlatColorUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
  const uniformBuffer = device.createBuffer({ size: uniformData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);

  const builtinsData = new Float32Array([
    0, 0, 0, 0,
    1, 1, 0, 0,
  ]);
  const builtinsBuffer = device.createBuffer({ size: builtinsData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(builtinsBuffer, 0, builtinsData);

  const bindGroupLayout = device.createBindGroupLayout({ entries: [
    { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
    { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
  ] });

  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
  const vertexModule = device.createShaderModule({ code: FlatColorVertexSource });
  const fragmentModule = device.createShaderModule({ code: FlatColorFragmentSource });

  const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    vertex: {
      module: vertexModule,
      entryPoint: 'main',
    buffers: [
      {
        arrayStride: 8,
        attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }],
      },
      {
        arrayStride: 8,
        attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x2' }],
      },
    ],
    },
    fragment: {
      module: fragmentModule,
      entryPoint: 'main',
      targets: [{ format }],
    },
    primitive: { topology: 'triangle-list', cullMode: 'none' },
  });

  const samplers: Record<string, GPUSampler> = {};
  const textureViews: Record<string, GPUTextureView> = {};

  let bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: { buffer: builtinsBuffer } },
    ],
  });

  const rebuildBindGroup = () => {
    bindGroup = device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: { buffer: builtinsBuffer } },
      ],
    });
  };

  const instance: FlatColorMaterialInstance = {
    pipeline,
    get bindGroup() { return bindGroup; },
    attributeOrder: ["position","uv"],
    setUniforms: (updates) => {
      currentUniforms = { ...currentUniforms, ...updates };
      packFlatColorUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
      device.queue.writeBuffer(uniformBuffer, 0, uniformData);
    },
    setBuiltins: (updates) => {
      if (updates.power2d_shapeTranslate) { builtinsData[0] = updates.power2d_shapeTranslate[0]; builtinsData[1] = updates.power2d_shapeTranslate[1]; }
      if (updates.power2d_shapeRotation !== undefined) { builtinsData[2] = updates.power2d_shapeRotation; }
      if (updates.power2d_shapeScale) { builtinsData[4] = updates.power2d_shapeScale[0]; builtinsData[5] = updates.power2d_shapeScale[1]; }
      if (updates.power2d_canvasWidth !== undefined) { builtinsData[6] = updates.power2d_canvasWidth; }
      if (updates.power2d_canvasHeight !== undefined) { builtinsData[7] = updates.power2d_canvasHeight; }
      device.queue.writeBuffer(builtinsBuffer, 0, builtinsData);
    },
    setTexture: (name, texture) => {
      textureViews[name] = texture;
      rebuildBindGroup();
    },
    setCanvasSize: (width, height) => {
      builtinsData[6] = width;
      builtinsData[7] = height;
      device.queue.writeBuffer(builtinsBuffer, 0, builtinsData);
    },
    dispose: () => {
      uniformBuffer.destroy();
      builtinsBuffer.destroy();
    },
  };

  return instance;
}

export interface FlatColorMaterialDef extends MaterialDef<FlatColorUniforms, FlatColorTextureName> {}
export const FlatColorMaterial: FlatColorMaterialDef = {
  createMaterial: createFlatColorMaterial,
  uniformDefaults: FlatColorUniformsDefaults,
  textureNames: FlatColorTextureNames,
};

export default FlatColorMaterial;
