// Auto-generated by power2d raw material generator. DO NOT EDIT.
import type { MaterialDef, MaterialInstance, BatchMaterialDef, InstanceAttrLayout } from '@avtools/power2d/raw';

export const InstancedSolidVertexSource = `// Auto-generated by power2d raw material generator. DO NOT EDIT.
@group(0) @binding(0) var<uniform> uniforms: InstancedSolidUniforms;
struct Power2DBuiltins {
  power2d_shapeTranslate: vec2f,
  power2d_shapeRotation: f32,
  _pad0: f32,
  power2d_shapeScale: vec2f,
  power2d_canvasWidth: f32,
  power2d_canvasHeight: f32,
};
@group(0) @binding(1) var<uniform> power2d: Power2DBuiltins;

struct InstancedSolidUniforms {
  color: vec4f,
};

struct InstancedSolidInstance {
  offset: vec2f,
  scale: f32,
  rotation: f32,
};

fn vertShader(
  position: vec2f,
  _uv: vec2f,
  _uniforms: InstancedSolidUniforms,
  inst: InstancedSolidInstance,
) -> vec2f {
  let c = cos(inst.rotation);
  let s = sin(inst.rotation);
  let rotated = vec2f(
    position.x * c - position.y * s,
    position.x * s + position.y * c,
  );
  return inst.offset + rotated * inst.scale;
}

fn fragShader(
  _uv: vec2f,
  uniforms: InstancedSolidUniforms,
  _inst: InstancedSolidInstance,
) -> vec4f {
  return uniforms.color;
}

struct VertexInput {
  @location(0) position: vec2f,
  @location(1) uv: vec2f,
  @location(2) inst_offset: vec2f,
  @location(3) inst_scale: f32,
  @location(4) inst_rotation: f32,
};
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) vUV: vec2f,
  @location(1) vInst_offset: vec2f,
  @location(2) vInst_scale: f32,
  @location(3) vInst_rotation: f32,
};

fn load_InstancedSolidInstance_vertex(input: VertexInput) -> InstancedSolidInstance {
  return InstancedSolidInstance(
    input.inst_offset,
    input.inst_scale,
    input.inst_rotation,
  );
}

fn power2d_applyShapeTransform(pixel: vec2f) -> vec2f {
  let scaled = pixel * power2d.power2d_shapeScale;
  let s = sin(power2d.power2d_shapeRotation);
  let c = cos(power2d.power2d_shapeRotation);
  let rotated = vec2f(
    scaled.x * c - scaled.y * s,
    scaled.x * s + scaled.y * c,
  );
  return rotated + power2d.power2d_shapeTranslate;
}

fn power2d_pixelToNDC(pixel: vec2f) -> vec4f {
  let ndcX = (pixel.x / power2d.power2d_canvasWidth) * 2.0 - 1.0;
  let ndcY = -((pixel.y / power2d.power2d_canvasHeight) * 2.0 - 1.0);
  return vec4f(ndcX, ndcY, 0.0, 1.0);
}

@vertex
fn main(input: VertexInput) -> VertexOutput {
  var out: VertexOutput;
  let instValue = load_InstancedSolidInstance_vertex(input);
  let pixelPos = input.position;
  let uv = input.uv;
  let adjustedPixelPos = vertShader(pixelPos, uv, uniforms, instValue);
  let transformedPixelPos = power2d_applyShapeTransform(adjustedPixelPos);
  out.position = power2d_pixelToNDC(transformedPixelPos);
  out.vUV = uv;
  out.vInst_offset = input.inst_offset;
  out.vInst_scale = input.inst_scale;
  out.vInst_rotation = input.inst_rotation;
  return out;
}

`;
export const InstancedSolidFragmentSource = `// Auto-generated by power2d raw material generator. DO NOT EDIT.
@group(0) @binding(0) var<uniform> uniforms: InstancedSolidUniforms;
struct Power2DBuiltins {
  power2d_shapeTranslate: vec2f,
  power2d_shapeRotation: f32,
  _pad0: f32,
  power2d_shapeScale: vec2f,
  power2d_canvasWidth: f32,
  power2d_canvasHeight: f32,
};
@group(0) @binding(1) var<uniform> power2d: Power2DBuiltins;

struct InstancedSolidUniforms {
  color: vec4f,
};

struct InstancedSolidInstance {
  offset: vec2f,
  scale: f32,
  rotation: f32,
};

fn vertShader(
  position: vec2f,
  _uv: vec2f,
  _uniforms: InstancedSolidUniforms,
  inst: InstancedSolidInstance,
) -> vec2f {
  let c = cos(inst.rotation);
  let s = sin(inst.rotation);
  let rotated = vec2f(
    position.x * c - position.y * s,
    position.x * s + position.y * c,
  );
  return inst.offset + rotated * inst.scale;
}

fn fragShader(
  _uv: vec2f,
  uniforms: InstancedSolidUniforms,
  _inst: InstancedSolidInstance,
) -> vec4f {
  return uniforms.color;
}

struct FragmentInput {
  @location(0) vUV: vec2f,
  @location(1) vInst_offset: vec2f,
  @location(2) vInst_scale: f32,
  @location(3) vInst_rotation: f32,
};

fn load_InstancedSolidInstance_fragment(input: FragmentInput) -> InstancedSolidInstance {
  return InstancedSolidInstance(
    input.vInst_offset,
    input.vInst_scale,
    input.vInst_rotation,
  );
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  let uv = input.vUV;
  let instValue = load_InstancedSolidInstance_fragment(input);
  return fragShader(uv, uniforms, instValue);
}

`;

export interface InstancedSolidUniforms {
  color: readonly [number, number, number, number];
}

export const InstancedSolidUniformsDefaults: InstancedSolidUniforms = {
  color: [0, 0, 0, 0],
};

export type InstancedSolidTextureName = never;
export const InstancedSolidTextureNames = [] as const;

export interface InstancedSolidInstance {
  offset: readonly [number, number];
  scale: number;
  rotation: number;
}

export const InstancedSolidInstanceAttrLayout: InstanceAttrLayout<InstancedSolidInstance> = {
  size: 4,
  members: [
    { name: 'offset', offset: 0, floatCount: 2 },
    { name: 'scale', offset: 2, floatCount: 1 },
    { name: 'rotation', offset: 3, floatCount: 1 },
  ],
};

const InstancedSolidUniformsLayoutSize = 16;

function packInstancedSolidUniforms(floatView: Float32Array, intView: Int32Array, uintView: Uint32Array, floatOffset: number, value: InstancedSolidUniforms): void {
  {
    const base = floatOffset + 0;
    const colorSource = value.color as any;
    for (let i = 0; i < 4; i++) {
      const component = colorSource?.[i];
      floatView[base + i] = component !== undefined ? Number(component) : 0;
    }
  }
}

export interface InstancedSolidMaterialInstance extends MaterialInstance<InstancedSolidUniforms, InstancedSolidTextureName> {}

export function createInstancedSolidMaterial(device: GPUDevice, format: GPUTextureFormat, name = 'InstancedSolidMaterial'): InstancedSolidMaterialInstance {
  const uniformData = new ArrayBuffer(16);
  const uniformFloats = new Float32Array(uniformData);
  const uniformInts = new Int32Array(uniformData);
  const uniformUints = new Uint32Array(uniformData);
  let currentUniforms: InstancedSolidUniforms = { ...InstancedSolidUniformsDefaults };
  packInstancedSolidUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
  const uniformBuffer = device.createBuffer({ size: uniformData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);

  const builtinsData = new Float32Array([
    0, 0, 0, 0,
    1, 1, 0, 0,
  ]);
  const builtinsBuffer = device.createBuffer({ size: builtinsData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  device.queue.writeBuffer(builtinsBuffer, 0, builtinsData);

  const bindGroupLayout = device.createBindGroupLayout({ entries: [
    { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
    { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
  ] });

  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
  const vertexModule = device.createShaderModule({ code: InstancedSolidVertexSource });
  const fragmentModule = device.createShaderModule({ code: InstancedSolidFragmentSource });

  const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    vertex: {
      module: vertexModule,
      entryPoint: 'main',
    buffers: [
      {
        arrayStride: 8,
        attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }],
      },
      {
        arrayStride: 8,
        attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x2' }],
      },
      {
        arrayStride: 16,
        stepMode: 'instance',
        attributes: [{ shaderLocation: 2, offset: 0, format: 'float32x2' }],
      },
      {
        arrayStride: 16,
        stepMode: 'instance',
        attributes: [{ shaderLocation: 3, offset: 8, format: 'float32' }],
      },
      {
        arrayStride: 16,
        stepMode: 'instance',
        attributes: [{ shaderLocation: 4, offset: 12, format: 'float32' }],
      },
    ],
    },
    fragment: {
      module: fragmentModule,
      entryPoint: 'main',
      targets: [{ format }],
    },
    primitive: { topology: 'triangle-list', cullMode: 'none' },
  });

  const samplers: Record<string, GPUSampler> = {};
  const textureViews: Record<string, GPUTextureView> = {};

  let bindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: { buffer: builtinsBuffer } },
    ],
  });

  const rebuildBindGroup = () => {
    bindGroup = device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: { buffer: builtinsBuffer } },
      ],
    });
  };

  const instance: InstancedSolidMaterialInstance = {
    pipeline,
    get bindGroup() { return bindGroup; },
    attributeOrder: ["position","uv","inst_offset","inst_scale","inst_rotation"],
    setUniforms: (updates) => {
      currentUniforms = { ...currentUniforms, ...updates };
      packInstancedSolidUniforms(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);
      device.queue.writeBuffer(uniformBuffer, 0, uniformData);
    },
    setBuiltins: (updates) => {
      if (updates.power2d_shapeTranslate) { builtinsData[0] = updates.power2d_shapeTranslate[0]; builtinsData[1] = updates.power2d_shapeTranslate[1]; }
      if (updates.power2d_shapeRotation !== undefined) { builtinsData[2] = updates.power2d_shapeRotation; }
      if (updates.power2d_shapeScale) { builtinsData[4] = updates.power2d_shapeScale[0]; builtinsData[5] = updates.power2d_shapeScale[1]; }
      if (updates.power2d_canvasWidth !== undefined) { builtinsData[6] = updates.power2d_canvasWidth; }
      if (updates.power2d_canvasHeight !== undefined) { builtinsData[7] = updates.power2d_canvasHeight; }
      device.queue.writeBuffer(builtinsBuffer, 0, builtinsData);
    },
    setTexture: (name, texture) => {
      textureViews[name] = texture;
      rebuildBindGroup();
    },
    setCanvasSize: (width, height) => {
      builtinsData[6] = width;
      builtinsData[7] = height;
      device.queue.writeBuffer(builtinsBuffer, 0, builtinsData);
    },
    dispose: () => {
      uniformBuffer.destroy();
      builtinsBuffer.destroy();
    },
  };

  return instance;
}

export interface InstancedSolidMaterialDef extends BatchMaterialDef<InstancedSolidUniforms, InstancedSolidTextureName, InstancedSolidInstance> {}
export const InstancedSolidMaterial: InstancedSolidMaterialDef = {
  createMaterial: createInstancedSolidMaterial,
  uniformDefaults: InstancedSolidUniformsDefaults,
  textureNames: InstancedSolidTextureNames,
  instanceAttrLayout: InstancedSolidInstanceAttrLayout,
};

export default InstancedSolidMaterial;
