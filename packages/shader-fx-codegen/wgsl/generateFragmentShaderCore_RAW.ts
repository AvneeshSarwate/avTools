import {
  ArgumentInfo,
  StructInfo,
  WgslReflect,
} from 'wgsl_reflect';
import {
  toPascalCase,
  escapeTemplateLiteral,
} from '../../codegen-common/utils.ts';

export const RAW_SUFFIX = '.fragFunc.wgsl';
export const TYPES_SUFFIX = '.frag.raw.generated.ts';

const HEADER_COMMENT = '// Auto-generated by raw WGSL fragment generator. DO NOT EDIT.';

interface UniformField {
  name: string;
  bindingName: string;
  wgslType: string;
  defaultExpression?: string;
  uiMin?: number;
  uiMax?: number;
  uiStep?: number;
  isArray?: boolean;
  arraySize?: number;
  elementType?: string;
}

interface UniformCommentAnnotation {
  defaultExpression?: string;
  uiMin?: number;
  uiMax?: number;
  uiStep?: number;
}

interface TextureParam {
  textureName: string;
  samplerName: string;
}

interface PassTextureBinding extends TextureParam {
  source: 'input' | 'pass';
  passIndex?: number;
}

interface PassAnalysis {
  index: number;
  name: string;
  args: ArgumentInfo[];
  resourceBindings: PassTextureBinding[];
}

interface ShaderAnalysis {
  shaderCode: string;
  shaderBaseName: string;
  shaderPrefix: string;
  effectClassName: string;
  uvArgName: string;
  uniformStruct: StructInfo | null;
  uniformFields: UniformField[];
  uniformArgName: string | null;
  uniformArgIsPointer: boolean;
  resourceStartIndex: number;
  baseTextureParams: TextureParam[];
  passAnalyses: PassAnalysis[];
  passTextureBindings: PassTextureBinding[][];
  textureParams: TextureParam[];
  inputTextureParams: TextureParam[];
  passCount: number;
}

interface UniformTypeMetadata {
  tsType: string;
}

const UNIFORM_TYPE_MAP: Record<string, UniformTypeMetadata> = {
  f32: { tsType: 'number' },
  i32: { tsType: 'number' },
  u32: { tsType: 'number' },
  bool: { tsType: 'boolean' },
  vec2f: { tsType: 'readonly [number, number]' },
  vec3f: { tsType: 'readonly [number, number, number]' },
  vec4f: { tsType: 'readonly [number, number, number, number]' },
  mat4x4f: { tsType: 'Float32Array | readonly number[]' },
};

interface PackTypeMapping {
  componentType: 'f32' | 'i32' | 'u32' | 'bool';
  valueLength: number;
  slotCount: number;
  defaultExpression: string;
}

const PACK_TYPE_MAP: Record<string, PackTypeMapping> = {
  f32: { componentType: 'f32', valueLength: 1, slotCount: 1, defaultExpression: '0' },
  i32: { componentType: 'i32', valueLength: 1, slotCount: 1, defaultExpression: '0' },
  u32: { componentType: 'u32', valueLength: 1, slotCount: 1, defaultExpression: '0' },
  bool: { componentType: 'bool', valueLength: 1, slotCount: 1, defaultExpression: 'false' },
  vec2f: { componentType: 'f32', valueLength: 2, slotCount: 2, defaultExpression: '[0, 0]' },
  vec3f: { componentType: 'f32', valueLength: 3, slotCount: 4, defaultExpression: '[0, 0, 0]' },
  vec4f: { componentType: 'f32', valueLength: 4, slotCount: 4, defaultExpression: '[0, 0, 0, 0]' },
  mat4x4f: { componentType: 'f32', valueLength: 16, slotCount: 16, defaultExpression: 'new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])' },
};

function packMappingFor(typeName: string): PackTypeMapping | null {
  return PACK_TYPE_MAP[typeName] ?? null;
}

interface ArrayUniformMeta {
  tsType: string;
}

const ARRAY_ELEMENT_TYPE_MAP: Record<string, ArrayUniformMeta> = {
  f32: { tsType: 'number[]' },
  i32: { tsType: 'number[]' },
  u32: { tsType: 'number[]' },
  vec2f: { tsType: 'readonly [number, number][]' },
  vec3f: { tsType: 'readonly [number, number, number][]' },
  vec4f: { tsType: 'readonly [number, number, number, number][]' },
};

function validateUvArgument(argument: ArgumentInfo): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== 'vec2f') {
    throw new Error(`First argument must be a vec2f called uv. Received ${argument.name}: ${typeName}`);
  }
}

function validateTextureArgument(argument: ArgumentInfo): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== 'texture_2d<f32>') {
    throw new Error(`Texture argument must be texture_2d<f32>. Received ${argument.name}: ${typeName}`);
  }
}

function validateSamplerArgument(argument: ArgumentInfo): void {
  const typeName = argument.type.getTypeName();
  if (typeName !== 'sampler') {
    throw new Error(`Sampler argument must be sampler. Received ${argument.name}: ${typeName}`);
  }
}

function collectUniformFields(struct: StructInfo, uniformArgName: string, shaderSource: string): UniformField[] {
  const annotationMap = extractUniformAnnotations(shaderSource, struct.name);
  return struct.members.map((member) => {
    if (member.type.isStruct) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${member.type.getTypeName()}. Nested structs are not supported.`);
    }
    const bindingName = `${uniformArgName}_${member.name}`;
    const annotations = annotationMap[member.name];

    if (member.type.isArray) {
      const elementType = member.format?.getTypeName();
      if (!elementType) {
        throw new Error(`Uniform field ${member.name} is an array but element type could not be determined.`);
      }
      if (!ARRAY_ELEMENT_TYPE_MAP[elementType]) {
        throw new Error(`Uniform array field ${member.name} uses unsupported element type ${elementType}.`);
      }
      const arraySize = member.count;
      if (!arraySize || arraySize <= 0) {
        throw new Error(`Uniform array field ${member.name} must have a fixed size.`);
      }
      return {
        name: member.name,
        bindingName,
        wgslType: member.type.getTypeName(),
        defaultExpression: annotations?.defaultExpression,
        uiMin: annotations?.uiMin,
        uiMax: annotations?.uiMax,
        uiStep: annotations?.uiStep,
        isArray: true,
        arraySize,
        elementType,
      };
    }

    const typeName = member.type.getTypeName();
    if (!UNIFORM_TYPE_MAP[typeName]) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    return {
      name: member.name,
      bindingName,
      wgslType: typeName,
      defaultExpression: annotations?.defaultExpression,
      uiMin: annotations?.uiMin,
      uiMax: annotations?.uiMax,
      uiStep: annotations?.uiStep,
    };
  });
}

function extractUniformAnnotations(source: string, structName: string): Record<string, UniformCommentAnnotation> {
  const annotations: Record<string, UniformCommentAnnotation> = {};
  const structRegex = new RegExp(`struct\\s+${structName}\\s*\\{`, 'g');
  const match = structRegex.exec(source);
  if (!match) {
    return annotations;
  }
  const braceStart = source.indexOf('{', match.index);
  if (braceStart === -1) {
    return annotations;
  }
  let depth = 0;
  let endIndex = braceStart;
  for (let i = braceStart; i < source.length; i++) {
    const char = source[i];
    if (char === '{') {
      depth++;
    } else if (char === '}') {
      depth--;
      if (depth === 0) {
        endIndex = i;
        break;
      }
    }
  }
  const body = source.slice(braceStart + 1, endIndex);
  const lines = body.split(/\r?\n/);
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) {
      continue;
    }
    const commentIndex = line.indexOf('//');
    if (commentIndex === -1) {
      continue;
    }
    const comment = line.slice(commentIndex + 2).trim();
    if (!comment) {
      continue;
    }
    const declarationPart = line.slice(0, commentIndex).trim().replace(/,+$/, '');
    const fieldMatch = declarationPart.match(/^([A-Za-z0-9_]+)\s*:/);
    if (!fieldMatch) {
      continue;
    }
    const fieldName = fieldMatch[1];
    const annotation = parseUniformComment(comment);
    if (annotation) {
      annotations[fieldName] = annotation;
    }
  }
  return annotations;
}

function parseUniformComment(comment: string): UniformCommentAnnotation | null {
  const trimmed = comment.trim();
  if (!trimmed) {
    return null;
  }
  const annotation: UniformCommentAnnotation = {};
  const defaultExpression = parseDefaultExpression(trimmed);
  if (defaultExpression !== null) {
    annotation.defaultExpression = defaultExpression;
  }
  const minMatch = trimmed.match(/(?:^|\s)min=([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
  const maxMatch = trimmed.match(/(?:^|\s)max=([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
  const stepMatch = trimmed.match(/(?:^|\s)step=([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
  if (minMatch) {
    const value = Number(minMatch[1]);
    if (!Number.isNaN(value)) {
      annotation.uiMin = value;
    }
  }
  if (maxMatch) {
    const value = Number(maxMatch[1]);
    if (!Number.isNaN(value)) {
      annotation.uiMax = value;
    }
  }
  if (stepMatch) {
    const value = Number(stepMatch[1]);
    if (!Number.isNaN(value)) {
      annotation.uiStep = value;
    }
  }
  return Object.keys(annotation).length > 0 ? annotation : null;
}

function parseDefaultExpression(comment: string): string | null {
  const trimmed = comment.trim();
  if (!trimmed || /^(?:min|max|step)=/i.test(trimmed)) {
    return null;
  }

  let candidate = trimmed;
  const firstChar = trimmed[0];

  if (firstChar === '[') {
    const match = trimmed.match(/^\[[^\]]*\]/);
    if (match) {
      candidate = match[0];
    }
  } else if (firstChar === '{') {
    const match = trimmed.match(/^\{[^}]*\}/);
    if (match) {
      candidate = match[0];
    }
  } else {
    // eslint-disable-next-line no-useless-escape
    const quotedMatch = trimmed.match(/^(\"[^\"]*\"|\'[^\']*\')/);
    if (quotedMatch) {
      candidate = quotedMatch[0];
    } else {
      const boolMatch = trimmed.match(/^(true|false)/i);
      if (boolMatch) {
        candidate = boolMatch[1].toLowerCase();
      } else {
        const numericMatch = trimmed.match(/^[-+]?(?:\d+\.\d*|\d*\.\d+|\d+)(?:[eE][-+]?\d+)?/);
        if (numericMatch && numericMatch[0] !== '') {
          candidate = numericMatch[0];
        } else {
          const firstToken = trimmed.split(/\s+/)[0];
          candidate = firstToken;
        }
      }
    }
  }

  try {
    const parsed = JSON.parse(candidate);
    if (typeof parsed === 'boolean') {
      return parsed ? 'true' : 'false';
    }
    if (typeof parsed === 'number') {
      return candidate;
    }
    if (typeof parsed === 'string') {
      return JSON.stringify(parsed);
    }
    return candidate;
  } catch (error) {
    const lower = candidate.toLowerCase();
    if (lower === 'true' || lower === 'false') {
      return lower;
    }
    const numeric = Number(candidate);
    if (!Number.isNaN(numeric)) {
      return candidate;
    }
  }
  return null;
}

function buildUniformInterface(
  struct: StructInfo,
  interfaceName: string,
): { interfaceLines: string[]; defaultsLines: string[] } {
  const interfaceLines: string[] = [];
  const defaultsLines: string[] = [];
  interfaceLines.push(`export interface ${interfaceName} {`);
  defaultsLines.push(`export const ${interfaceName}Defaults: ${interfaceName} = {`);
  for (const member of struct.members) {
    if (member.type.isStruct) {
      throw new Error(`Uniform field ${member.name} uses unsupported struct type ${member.type.getTypeName()}.`);
    }
    if (member.type.isArray) {
      const elementType = member.format?.getTypeName();
      if (!elementType) {
        throw new Error(`Uniform array field ${member.name} element type could not be determined.`);
      }
      const arrayMeta = ARRAY_ELEMENT_TYPE_MAP[elementType];
      if (!arrayMeta) {
        throw new Error(`Uniform array field ${member.name} uses unsupported element type ${elementType}.`);
      }
      const packMeta = packMappingFor(elementType);
      if (!packMeta) {
        throw new Error(`Uniform array field ${member.name} uses unsupported element type ${elementType}.`);
      }
      const count = member.count ?? 0;
      interfaceLines.push(`  ${member.name}: readonly ${arrayMeta.tsType};`);
      defaultsLines.push(`  ${member.name}: Array.from({ length: ${count} }, () => ${packMeta.defaultExpression}),`);
      continue;
    }
    const typeName = member.type.getTypeName();
    const typeMeta = UNIFORM_TYPE_MAP[typeName];
    const packMeta = packMappingFor(typeName);
    if (!typeMeta || !packMeta) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    interfaceLines.push(`  ${member.name}: ${typeMeta.tsType};`);
    defaultsLines.push(`  ${member.name}: ${packMeta.defaultExpression},`);
  }
  interfaceLines.push('}');
  defaultsLines.push('};');
  return { interfaceLines, defaultsLines };
}

function buildUniformPacker(struct: StructInfo): { packLines: string[]; needsInt: boolean; needsUint: boolean } {
  const packLines: string[] = [];
  let needsInt = false;
  let needsUint = false;

  for (const member of struct.members) {
    const offsetSlots = member.offset / 4;
    if (member.type.isArray) {
      const elementType = member.format?.getTypeName();
      if (!elementType) {
        throw new Error(`Uniform array field ${member.name} element type could not be determined.`);
      }
      const mapping = packMappingFor(elementType);
      if (!mapping) {
        throw new Error(`Uniform array field ${member.name} uses unsupported element type ${elementType}.`);
      }
      if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
        needsInt = true;
      }
      if (mapping.componentType === 'u32') {
        needsUint = true;
      }
      const count = member.count ?? 0;
      const strideSlots = member.size / 4 / Math.max(1, count);
      packLines.push('  {');
      packLines.push(`    const values = value.${member.name} ?? [];`);
      packLines.push(`    for (let i = 0; i < ${count}; i++) {`);
      packLines.push(`      const base = floatOffset + ${offsetSlots} + i * ${strideSlots};`);
      if (mapping.valueLength > 1) {
        packLines.push('      const source = values[i] as any;');
        packLines.push(`      for (let c = 0; c < ${mapping.valueLength}; c++) {`);
        packLines.push('        const component = source?.[c];');
        switch (mapping.componentType) {
          case 'f32':
            packLines.push('        floatView[base + c] = component !== undefined ? Number(component) : 0;');
            break;
          case 'i32':
            packLines.push('        intView[base + c] = component !== undefined ? Math.trunc(component as number) : 0;');
            break;
          case 'u32':
            packLines.push('        uintView[base + c] = component !== undefined ? Math.trunc(component as number) >>> 0 : 0;');
            break;
          case 'bool':
            packLines.push('        intView[base + c] = component ? 1 : 0;');
            break;
        }
        packLines.push('      }');
        if (strideSlots > mapping.valueLength) {
          packLines.push(`      for (let c = ${mapping.valueLength}; c < ${strideSlots}; c++) {`);
          if (mapping.componentType === 'u32') {
            packLines.push('        uintView[base + c] = 0;');
          } else if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
            packLines.push('        intView[base + c] = 0;');
          } else {
            packLines.push('        floatView[base + c] = 0;');
          }
          packLines.push('      }');
        }
      } else {
        packLines.push('      const component = values[i];');
        switch (mapping.componentType) {
          case 'f32':
            packLines.push('      floatView[base] = component !== undefined ? Number(component) : 0;');
            break;
          case 'i32':
            packLines.push('      intView[base] = component !== undefined ? Math.trunc(component as number) : 0;');
            break;
          case 'u32':
            packLines.push('      uintView[base] = component !== undefined ? Math.trunc(component as number) >>> 0 : 0;');
            break;
          case 'bool':
            packLines.push('      intView[base] = component ? 1 : 0;');
            break;
        }
        if (strideSlots > 1) {
          packLines.push(`      for (let c = 1; c < ${strideSlots}; c++) {`);
          if (mapping.componentType === 'u32') {
            packLines.push('        uintView[base + c] = 0;');
          } else if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
            packLines.push('        intView[base + c] = 0;');
          } else {
            packLines.push('        floatView[base + c] = 0;');
          }
          packLines.push('      }');
        }
      }
      packLines.push('    }');
      packLines.push('  }');
      continue;
    }

    const typeName = member.type.getTypeName();
    const mapping = packMappingFor(typeName);
    if (!mapping) {
      throw new Error(`Uniform field ${member.name} uses unsupported type ${typeName}.`);
    }
    if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
      needsInt = true;
    }
    if (mapping.componentType === 'u32') {
      needsUint = true;
    }
    packLines.push('  {');
    packLines.push(`    const base = floatOffset + ${offsetSlots};`);
    if (mapping.valueLength === 1) {
      switch (mapping.componentType) {
        case 'f32':
          packLines.push(`    const raw = value.${member.name};`);
          packLines.push('    floatView[base] = raw !== undefined ? Number(raw) : 0;');
          break;
        case 'i32':
          packLines.push(`    const raw = value.${member.name};`);
          packLines.push('    intView[base] = raw !== undefined ? Math.trunc(raw as number) : 0;');
          break;
        case 'u32':
          packLines.push(`    const raw = value.${member.name};`);
          packLines.push('    uintView[base] = raw !== undefined ? Math.trunc(raw as number) >>> 0 : 0;');
          break;
        case 'bool':
          packLines.push(`    const raw = value.${member.name};`);
          packLines.push('    intView[base] = raw ? 1 : 0;');
          break;
      }
    } else {
      const sourceVar = `value_${member.name}`;
      packLines.push(`    const ${sourceVar} = value.${member.name} as any;`);
      packLines.push(`    for (let i = 0; i < ${mapping.valueLength}; i++) {`);
      packLines.push(`      const component = ${sourceVar}?.[i];`);
      switch (mapping.componentType) {
        case 'f32':
          packLines.push('      floatView[base + i] = component !== undefined ? Number(component) : 0;');
          break;
        case 'i32':
          packLines.push('      intView[base + i] = component !== undefined ? Math.trunc(component as number) : 0;');
          break;
        case 'u32':
          packLines.push('      uintView[base + i] = component !== undefined ? Math.trunc(component as number) >>> 0 : 0;');
          break;
        case 'bool':
          packLines.push('      intView[base + i] = component ? 1 : 0;');
          break;
      }
      packLines.push('    }');
      if (mapping.slotCount > mapping.valueLength) {
        packLines.push(`    for (let i = ${mapping.valueLength}; i < ${mapping.slotCount}; i++) {`);
        if (mapping.componentType === 'u32') {
          packLines.push('      uintView[base + i] = 0;');
        } else if (mapping.componentType === 'i32' || mapping.componentType === 'bool') {
          packLines.push('      intView[base + i] = 0;');
        } else {
          packLines.push('      floatView[base + i] = 0;');
        }
        packLines.push('    }');
      }
    }
    packLines.push('  }');
  }

  return { packLines, needsInt, needsUint };
}

function generateUniformStructConstruction(struct: StructInfo, fields: UniformField[]): string {
  if (fields.length === 0) {
    return '';
  }
  // Use assignment syntax instead of constructor to support arrays
  const assignments = fields
    .map((field) => {
      if (field.isArray && field.arraySize) {
        return `  for (var i = 0; i < ${field.arraySize}; i = i + 1) {\n    result.${field.name}[i] = uniforms.${field.bindingName}[i];\n  }`;
      }
      return `  result.${field.name} = uniforms.${field.bindingName};`;
    })
    .join('\n');
  return `fn load_${struct.name}() -> ${struct.name} {\n  var result: ${struct.name};\n${assignments}\n  return result;\n}`;
}

function buildVertexSource(varyingName: string): string {
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push('struct VertexOutput {');
  lines.push('  @builtin(position) position: vec4f,');
  lines.push(`  @location(0) ${varyingName}: vec2f,`);
  lines.push('};');
  lines.push('');
  lines.push('@vertex');
  lines.push('fn main(@builtin(vertex_index) index: u32) -> VertexOutput {');
  lines.push('  var positions = array<vec2f, 3>(');
  lines.push('    vec2f(-1.0, -1.0),');
  lines.push('    vec2f(3.0, -1.0),');
  lines.push('    vec2f(-1.0, 3.0),');
  lines.push('  );');
  lines.push('  var uvs = array<vec2f, 3>(');
  lines.push('    vec2f(0.0, 1.0),');
  lines.push('    vec2f(2.0, 1.0),');
  lines.push('    vec2f(0.0, -1.0),');
  lines.push('  );');
  lines.push('  var out: VertexOutput;');
  lines.push('  out.position = vec4f(positions[index], 0.0, 1.0);');
  lines.push(`  out.${varyingName} = uvs[index];`);
  lines.push('  return out;');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function buildFragmentSource(options: {
  shaderCode: string;
  uniformStruct: StructInfo | null;
  textureBindings: Array<{ param: TextureParam; textureBinding: number; samplerBinding: number }>;
  passName: string;
  uvArgName: string;
  uniformArgName: string | null;
  uniformArgIsPointer: boolean;
  passArgs: ArgumentInfo[];
  resourceStartIndex: number;
  varyingName: string;
}): string {
  const {
    shaderCode,
    uniformStruct,
    textureBindings,
    passName,
    uvArgName,
    uniformArgName,
    uniformArgIsPointer,
    passArgs,
    resourceStartIndex,
    varyingName,
  } = options;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push(shaderCode.trimEnd());
  lines.push('');

  if (uniformStruct) {
    lines.push(`@group(0) @binding(0) var<uniform> uniforms: ${uniformStruct.name};`);
  }

  for (const entry of textureBindings) {
    lines.push(`@group(0) @binding(${entry.textureBinding}) var ${entry.param.textureName}: texture_2d<f32>;`);
    lines.push(`@group(0) @binding(${entry.samplerBinding}) var ${entry.param.samplerName}: sampler;`);
  }

  lines.push('');
  lines.push('struct FragmentInput {');
  lines.push(`  @location(0) ${varyingName}: vec2f,`);
  lines.push('};');
  lines.push('');
  lines.push('@fragment');
  lines.push('fn main(input: FragmentInput) -> @location(0) vec4f {');

  const uvLocalName = `${uvArgName}_local`;
  lines.push(`  let ${uvLocalName} = input.${varyingName};`);

  const resourceArgNames = passArgs.slice(resourceStartIndex).map((argument) => argument.name);
  const args: string[] = [uvLocalName];

  if (uniformStruct) {
    const uniformVarName = `${uniformArgName ?? 'uniforms'}_value`;
    if (uniformArgIsPointer) {
      lines.push(`  var ${uniformVarName} = uniforms;`);
      args.push(`&${uniformVarName}`);
    } else {
      lines.push(`  let ${uniformVarName} = uniforms;`);
      args.push(uniformVarName);
    }
  }

  resourceArgNames.forEach((name) => {
    args.push(name);
  });
  lines.push(`  let color = ${passName}(${args.join(', ')});`);
  lines.push('  return color;');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function analyzeShaderSource(
  shaderCode: string,
  reflect: WgslReflect,
  shaderBaseName: string,
): ShaderAnalysis {
  const shaderPrefix = toPascalCase(shaderBaseName);
  const effectClassName = `${shaderPrefix}Effect`;

  const freeFunctions = reflect.functions.filter((fn) => !fn.stage);
  const passFunctions = freeFunctions.filter((fn) => /^pass\d+$/.test(fn.name));

  if (passFunctions.length === 0) {
    const helperNames = freeFunctions.map((fn) => fn.name).join(', ');
    const suffix = helperNames ? ` Found helper functions: ${helperNames}` : '';
    throw new Error(`No pass functions found. Expected one or more functions named pass0, pass1, ... in fragment shader.${suffix}`);
  }

  const indexedPasses = passFunctions
    .map((fn) => {
      const index = Number(fn.name.replace('pass', ''));
      if (!Number.isInteger(index)) {
        throw new Error(`Pass function ${fn.name} uses an invalid index.`);
      }
      return { fn, index };
    })
    .sort((a, b) => a.index - b.index);

  const seenIndexes = new Set<number>();
  indexedPasses.forEach(({ index }) => {
    if (seenIndexes.has(index)) {
      throw new Error(`Duplicate pass index detected for pass${index}.`);
    }
    seenIndexes.add(index);
  });

  indexedPasses.forEach(({ index }) => {
    if (index < 0) {
      throw new Error(`Pass indexes must start at 0. Received pass${index}.`);
    }
  });

  indexedPasses.forEach(({ index }, position) => {
    if (index !== position) {
      throw new Error(`Missing pass${position}. Pass functions must form a contiguous sequence starting at pass0.`);
    }
  });

  const orderedPassFunctions = indexedPasses.map(({ fn }) => fn);
  const passCount = orderedPassFunctions.length;

  orderedPassFunctions.forEach((fn) => {
    const returnType = fn.returnType?.getTypeName();
    if (returnType !== 'vec4f') {
      throw new Error(`Fragment pass ${fn.name} must return vec4f. Received ${returnType ?? 'void'}.`);
    }
  });

  const primaryPass = orderedPassFunctions[0];
  const primaryArgs = primaryPass.arguments;
  if (primaryArgs.length < 3) {
    throw new Error('Fragment function must include uv followed by at least one texture/sampler pair.');
  }

  const uvArg = primaryArgs[0];
  validateUvArgument(uvArg);
  const uvArgName = uvArg.name;

  let uniformStruct: StructInfo | null = null;
  let uniformFields: UniformField[] = [];
  let uniformArgName: string | null = null;
  let uniformArgIsPointer = false;
  let resourceStartIndex = 1;

  if (primaryArgs.length >= 4) {
    const potentialUniform = primaryArgs[1];
    const typeName = potentialUniform.type.getTypeName();
    let structInfo = reflect.structs.find((entry) => entry.name === typeName);
    if (!structInfo) {
      const pointerMatch = /^&(.+)$/.exec(typeName);
      if (pointerMatch) {
        structInfo = reflect.structs.find((entry) => entry.name === pointerMatch[1]);
        if (structInfo) {
          uniformArgIsPointer = true;
        }
      }
    }
    if (structInfo) {
      uniformStruct = structInfo;
      uniformArgName = potentialUniform.name;
      uniformFields = collectUniformFields(structInfo, uniformArgName, shaderCode);
      resourceStartIndex = 2;
    }
  }

  const baseArgumentNames = primaryArgs.slice(0, resourceStartIndex).map((argument) => argument.name);
  const baseArgumentTypes = primaryArgs.slice(0, resourceStartIndex).map((argument) => argument.type.getTypeName());

  const passAnalyses: PassAnalysis[] = [];
  const passTextureBindings: PassTextureBinding[][] = [];
  const baseTextureParams: TextureParam[] = [];
  const baseTextureLookup = new Map<string, TextureParam>();
  const textureParamMap = new Map<string, TextureParam>();

  const analyzePassResources = (
    passFn: typeof primaryPass,
    passIndex: number,
  ): PassTextureBinding[] => {
    const passArgs = passFn.arguments;
    if (passArgs.length < resourceStartIndex) {
      throw new Error(
        `${passFn.name} must declare at least ${resourceStartIndex} arguments (uv${uniformStruct ? ', uniforms' : ''}).`,
      );
    }

    for (let index = 0; index < resourceStartIndex; index++) {
      const expectedName = baseArgumentNames[index];
      const expectedType = baseArgumentTypes[index];
      const argument = passArgs[index];
      if (!argument) {
        throw new Error(`Argument ${index} of ${passFn.name} must be ${expectedType} named ${expectedName}.`);
      }
      const actualType = argument.type.getTypeName();
      if (actualType !== expectedType) {
        throw new Error(`Argument ${index} of ${passFn.name} must be ${expectedType}. Received ${actualType}.`);
      }
      if (argument.name !== expectedName) {
        throw new Error(`Argument ${index} of ${passFn.name} must be named ${expectedName}. Received ${argument.name}.`);
      }
    }

    const bindings: PassTextureBinding[] = [];
    const seenPassDependencies = new Set<number>();
    const seenTextureNames = new Set<string>();
    const extraCount = passArgs.length - resourceStartIndex;
    if (extraCount < 0 || extraCount % 2 !== 0) {
      throw new Error(`Additional arguments for ${passFn.name} must be provided in texture/sampler pairs.`);
    }

    for (let offset = 0; offset < extraCount; offset += 2) {
      const argumentIndex = resourceStartIndex + offset;
      const textureArg = passArgs[argumentIndex];
      const samplerArg = passArgs[argumentIndex + 1];
      if (!samplerArg) {
        throw new Error('Texture parameter must be followed by a sampler parameter.');
      }
      validateTextureArgument(textureArg);
      validateSamplerArgument(samplerArg);
      if (seenTextureNames.has(textureArg.name)) {
        throw new Error(`Duplicate texture parameter ${textureArg.name} detected in ${passFn.name}.`);
      }
      seenTextureNames.add(textureArg.name);

      const passDependencyMatch = /^pass(\d+)Texture$/.exec(textureArg.name);
      if (passDependencyMatch) {
        const dependencyIndex = Number(passDependencyMatch[1]);
        if (!Number.isInteger(dependencyIndex)) {
          throw new Error(`Invalid pass dependency ${textureArg.name} in ${passFn.name}.`);
        }
        if (dependencyIndex < 0 || dependencyIndex >= passIndex) {
          throw new Error(
            `Pass ${passFn.name} can only depend on earlier passes. Received dependency on pass${dependencyIndex}.`,
          );
        }
        if (seenPassDependencies.has(dependencyIndex)) {
          throw new Error(`Duplicate dependency on pass${dependencyIndex} detected in ${passFn.name}.`);
        }
        seenPassDependencies.add(dependencyIndex);
        const expectedSamplerName = `pass${dependencyIndex}Sampler`;
        if (samplerArg.name !== expectedSamplerName) {
          throw new Error(
            `Sampler parameter for dependency ${textureArg.name} must be named ${expectedSamplerName}. Received ${samplerArg.name}.`,
          );
        }
        bindings.push({
          textureName: textureArg.name,
          samplerName: samplerArg.name,
          source: 'pass',
          passIndex: dependencyIndex,
        });
        if (!textureParamMap.has(textureArg.name)) {
          textureParamMap.set(textureArg.name, {
            textureName: textureArg.name,
            samplerName: samplerArg.name,
          });
        }
        continue;
      }

      const baseTexture = baseTextureLookup.get(textureArg.name);
      if (!baseTexture) {
        if (passIndex === 0) {
          const expectedSamplerName = `${textureArg.name}Sampler`;
          if (samplerArg.name !== expectedSamplerName) {
            throw new Error(
              `Sampler parameter must be named ${expectedSamplerName} to match the texture parameter ${textureArg.name}.`,
            );
          }
          const param: TextureParam = {
            textureName: textureArg.name,
            samplerName: samplerArg.name,
          };
          baseTextureParams.push(param);
          baseTextureLookup.set(textureArg.name, param);
          textureParamMap.set(textureArg.name, param);
          bindings.push({
            textureName: textureArg.name,
            samplerName: samplerArg.name,
            source: 'input',
          });
        } else {
          throw new Error(
            `Pass ${passFn.name} references unknown texture ${textureArg.name}. Base textures must be declared in pass0.`,
          );
        }
        continue;
      }

      const expectedSamplerName = baseTexture.samplerName;
      if (samplerArg.name !== expectedSamplerName) {
        throw new Error(
          `Sampler parameter must be named ${expectedSamplerName} to match the texture parameter ${textureArg.name}.`,
        );
      }
      bindings.push({
        textureName: textureArg.name,
        samplerName: samplerArg.name,
        source: 'input',
      });
    }

    return bindings;
  };

  orderedPassFunctions.forEach((passFn, passIndex) => {
    const bindings = analyzePassResources(passFn, passIndex);
    passAnalyses.push({
      index: passIndex,
      name: passFn.name,
      args: passFn.arguments,
      resourceBindings: bindings,
    });
    passTextureBindings.push(bindings);
  });

  if (baseTextureParams.length === 0) {
    throw new Error('At least one texture argument is required for a pass.');
  }

  const textureParams = Array.from(textureParamMap.values());

  return {
    shaderCode,
    shaderBaseName,
    shaderPrefix,
    effectClassName,
    uvArgName,
    uniformStruct,
    uniformFields,
    uniformArgName,
    uniformArgIsPointer,
    resourceStartIndex,
    baseTextureParams,
    passAnalyses,
    passTextureBindings,
    textureParams,
    inputTextureParams: baseTextureParams,
    passCount,
  };
}

export interface FragmentShaderNaming {
  shaderPrefix: string;
  effectClassName: string;
  defaultUniformInterfaceName: string;
}

export function getFragmentShaderNaming(shaderBaseName: string): FragmentShaderNaming {
  const shaderPrefix = toPascalCase(shaderBaseName);
  return {
    shaderPrefix,
    effectClassName: `${shaderPrefix}Effect`,
    defaultUniformInterfaceName: `${shaderPrefix}Uniforms`,
  };
}

export interface GenerateFragmentShaderArtifactsSourceOptions {
  shaderCode: string;
  shaderBaseName: string;
  shaderFxImportPath: string;
}

export interface GenerateFragmentShaderArtifactsSourceResult {
  typesSource: string;
  shaderPrefix: string;
  effectClassName: string;
  uniformInterfaceName: string;
}

export function generateFragmentShaderArtifactsSource(
  options: GenerateFragmentShaderArtifactsSourceOptions,
): GenerateFragmentShaderArtifactsSourceResult {
  const { shaderCode, shaderBaseName, shaderFxImportPath } = options;

  const naming = getFragmentShaderNaming(shaderBaseName);
  const { shaderPrefix, effectClassName, defaultUniformInterfaceName } = naming;

  const reflect = new WgslReflect(shaderCode);
  const analysis = analyzeShaderSource(shaderCode, reflect, shaderBaseName);
  const {
    uvArgName,
    uniformStruct,
    uniformFields,
    uniformArgName,
    uniformArgIsPointer,
    resourceStartIndex,
    baseTextureParams,
    passAnalyses,
    passTextureBindings,
    textureParams,
    inputTextureParams,
    passCount,
  } = analysis;

  const primaryTextureName = inputTextureParams[0]?.textureName;
  if (!primaryTextureName) {
    throw new Error('At least one texture argument is required for a pass.');
  }

  const shaderFxImports = [
    'CustomShaderEffect',
    'type ShaderSource',
    'type UniformDescriptor',
    'type MaterialHandles',
  ];
  if (uniformFields.length > 0) {
    shaderFxImports.push('type ShaderUniforms', 'type Dynamic');
  }

  const varyingName = 'vUV';
  const vertexSource = buildVertexSource(varyingName);

  const hasUniforms = Boolean(uniformStruct);
  const bindingBase = hasUniforms ? 1 : 0;
  const textureBindingEntries = textureParams.map((param, index) => {
    const textureBinding = bindingBase + index * 2;
    const samplerBinding = textureBinding + 1;
    return { param, textureBinding, samplerBinding };
  });

  const fragmentSources = passAnalyses.map((passInfo) => buildFragmentSource({
    shaderCode,
    uniformStruct,
    textureBindings: textureBindingEntries,
    passName: passInfo.name,
    uvArgName,
    uniformArgName,
    uniformArgIsPointer,
    passArgs: passInfo.args,
    resourceStartIndex,
    varyingName,
  }));

  const uniformInterfaceName = uniformStruct
    ? (uniformStruct.name.startsWith(shaderPrefix) ? uniformStruct.name : `${shaderPrefix}${uniformStruct.name}`)
    : defaultUniformInterfaceName;

  const uniformMetaConstName = `${shaderPrefix}UniformMeta`;
  const materialHandlesName = `${shaderPrefix}MaterialHandles`;
  const materialOptionsName = `${shaderPrefix}MaterialOptions`;

  const textureNameUnion = textureParams.length
    ? textureParams.map((param) => `'${param.textureName}'`).join(' | ')
    : 'never';
  const textureNamesLiteral = textureParams.length
    ? `[${textureParams.map((param) => `'${param.textureName}'`).join(', ')}] as const`
    : '[] as const';
  const inputTextureNamesArrayLiteral = `[${inputTextureParams.map((param) => `'${param.textureName}'`).join(', ')}]`;

  const tsLines: string[] = [];
  tsLines.push(HEADER_COMMENT);
  tsLines.push(`import { ${shaderFxImports.join(', ')} } from '${shaderFxImportPath}';`);
  tsLines.push(`export const ${shaderPrefix}VertexSource = ${escapeTemplateLiteral(vertexSource)};`);
  tsLines.push(`export const ${shaderPrefix}FragmentSources = [`);
  fragmentSources.forEach((source, index) => {
    tsLines.push(`  ${escapeTemplateLiteral(source)}, // pass${index}`);
  });
  tsLines.push(`] as const;`);
  tsLines.push(`export const ${shaderPrefix}PassCount = ${passCount} as const;`);
  tsLines.push(`export const ${shaderPrefix}PrimaryTextureName = '${primaryTextureName}' as const;`);
  tsLines.push('');

  const passTextureSourceLines: string[] = [];
  passTextureSourceLines.push(`export const ${shaderPrefix}PassTextureSources = [`);
  passTextureBindings.forEach((bindings) => {
    passTextureSourceLines.push('  [');
    bindings.forEach((binding) => {
      if (binding.source === 'input') {
        passTextureSourceLines.push(
          `    { binding: '${binding.textureName}', source: { kind: 'input', key: '${binding.textureName}' } },`,
        );
      } else {
        passTextureSourceLines.push(
          `    { binding: '${binding.textureName}', source: { kind: 'pass', passIndex: ${binding.passIndex} } },`,
        );
      }
    });
    passTextureSourceLines.push('  ],');
  });
  passTextureSourceLines.push(`] as const;`);
  passTextureSourceLines.push('');
  tsLines.push(...passTextureSourceLines);

  const uniformMetaLines: string[] = [];
  if (uniformFields.length > 0) {
    uniformMetaLines.push(`export const ${uniformMetaConstName}: UniformDescriptor[] = [`);
    uniformFields.forEach((field) => {
      uniformMetaLines.push('  {');
      uniformMetaLines.push(`    name: '${field.name}',`);
      if (field.isArray && field.elementType) {
        uniformMetaLines.push(`    kind: '${field.elementType}',`);
        uniformMetaLines.push(`    isArray: true,`);
        uniformMetaLines.push(`    arraySize: ${field.arraySize},`);
      } else {
        uniformMetaLines.push(`    kind: '${field.wgslType}',`);
      }
      uniformMetaLines.push(`    bindingName: '${field.bindingName}',`);
      if (field.defaultExpression) {
        uniformMetaLines.push(`    default: ${field.defaultExpression},`);
      }
      const uiEntries: string[] = [];
      if (field.uiMin !== undefined) {
        uiEntries.push(`min: ${field.uiMin}`);
      }
      if (field.uiMax !== undefined) {
        uiEntries.push(`max: ${field.uiMax}`);
      }
      if (field.uiStep !== undefined) {
        uiEntries.push(`step: ${field.uiStep}`);
      }
      if (uiEntries.length > 0) {
        uniformMetaLines.push(`    ui: { ${uiEntries.join(', ')} },`);
      }
      uniformMetaLines.push('  },');
    });
    uniformMetaLines.push('];');
  } else {
    uniformMetaLines.push(`export const ${uniformMetaConstName}: UniformDescriptor[] = [];`);
  }
  uniformMetaLines.push('');
  tsLines.push(...uniformMetaLines);

  if (uniformStruct) {
    const { interfaceLines, defaultsLines } = buildUniformInterface(uniformStruct, uniformInterfaceName);
    const { packLines } = buildUniformPacker(uniformStruct);
    tsLines.push(...interfaceLines);
    tsLines.push('');
    tsLines.push(...defaultsLines);
    tsLines.push('');
    tsLines.push(`const ${uniformStruct.name}LayoutSize = ${uniformStruct.size};`);
    tsLines.push('');
    tsLines.push(`function pack${uniformStruct.name}(floatView: Float32Array, intView: Int32Array, uintView: Uint32Array, floatOffset: number, value: ${uniformInterfaceName}): void {`);
    tsLines.push(...packLines.length ? packLines : ['  // No uniforms to pack']);
    tsLines.push('}');
    tsLines.push('');

  } else {
    tsLines.push(`export type ${uniformInterfaceName} = Record<string, never>;`);
    tsLines.push(`export const ${uniformInterfaceName}Defaults = {};`);
    tsLines.push('');
  }

  const inputsTypeName = `${shaderPrefix}Inputs`;
  tsLines.push(`export type ${shaderPrefix}TextureName = ${textureNameUnion};`);
  tsLines.push(`export const ${shaderPrefix}TextureNames = ${textureNamesLiteral};`);
  tsLines.push(`export interface ${inputsTypeName} {`);
  inputTextureParams.forEach((param) => {
    tsLines.push(`  ${param.textureName}: ShaderSource;`);
  });
  tsLines.push('}');
  tsLines.push('');
  tsLines.push(`export type ${materialHandlesName} = MaterialHandles<${uniformInterfaceName}, ${shaderPrefix}TextureName>;`);
  tsLines.push('');
  tsLines.push(`export interface ${materialOptionsName} {`);
  tsLines.push('  name?: string;');
  tsLines.push('  passIndex?: number;');
  tsLines.push('}');
  tsLines.push('');

  tsLines.push(`export function create${shaderPrefix}Material(device: GPUDevice, format: GPUTextureFormat, options: ${materialOptionsName} = {}): ${materialHandlesName} {`);
  tsLines.push('  const passIndex = options.passIndex ?? 0;');
  tsLines.push(`  if (passIndex < 0 || passIndex >= ${passCount}) {`);
  tsLines.push(`    throw new Error(\`Invalid passIndex \${passIndex} for ${shaderPrefix}. Expected 0 <= passIndex < ${passCount}.\`);`);
  tsLines.push('  }');
  if (uniformStruct) {
    tsLines.push(`  const uniformData = new ArrayBuffer(${uniformStruct.name}LayoutSize);`);
    tsLines.push('  const uniformFloats = new Float32Array(uniformData);');
    tsLines.push('  const uniformInts = new Int32Array(uniformData);');
    tsLines.push('  const uniformUints = new Uint32Array(uniformData);');
    tsLines.push(`  let currentUniforms: ${uniformInterfaceName} = { ...${uniformInterfaceName}Defaults };`);
    tsLines.push(`  pack${uniformStruct.name}(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);`);
    tsLines.push('  const uniformBuffer = device.createBuffer({ size: uniformData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });');
    tsLines.push('  device.queue.writeBuffer(uniformBuffer, 0, uniformData);');
    tsLines.push('');
  }

  tsLines.push('  const bindGroupLayout = device.createBindGroupLayout({ entries: [');
  if (uniformStruct) {
    tsLines.push('    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },');
  }
  for (const entry of textureBindingEntries) {
    tsLines.push(`    { binding: ${entry.textureBinding}, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },`);
    tsLines.push(`    { binding: ${entry.samplerBinding}, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },`);
  }
  tsLines.push('  ] });');
  tsLines.push('');
  tsLines.push('  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });');
  tsLines.push(`  const vertexModule = device.createShaderModule({ code: ${shaderPrefix}VertexSource });`);
  tsLines.push(`  const fragmentModule = device.createShaderModule({ code: ${shaderPrefix}FragmentSources[passIndex] });`);
  tsLines.push('');
  tsLines.push('  const pipeline = device.createRenderPipeline({');
  tsLines.push('    layout: pipelineLayout,');
  tsLines.push('    vertex: { module: vertexModule, entryPoint: "main" },');
  tsLines.push('    fragment: { module: fragmentModule, entryPoint: "main", targets: [{ format }] },');
  tsLines.push('    primitive: { topology: "triangle-list", cullMode: "none" },');
  tsLines.push('  });');
  tsLines.push('');
  tsLines.push('  const samplers: Record<string, GPUSampler> = {};');
  tsLines.push('  const textureViews: Record<string, GPUTextureView> = {};');
  if (textureBindingEntries.length > 0) {
    tsLines.push(`  for (const name of ${shaderPrefix}TextureNames) {`);
    tsLines.push('    samplers[name] = device.createSampler({ magFilter: "linear", minFilter: "linear" });');
    tsLines.push('    const placeholder = device.createTexture({ size: { width: 1, height: 1 }, format, usage: GPUTextureUsage.TEXTURE_BINDING });');
    tsLines.push('    textureViews[name] = placeholder.createView();');
    tsLines.push('  }');
  }
  tsLines.push('');

  tsLines.push('  let bindGroup = device.createBindGroup({');
  tsLines.push('    layout: bindGroupLayout,');
  tsLines.push('    entries: [');
  if (uniformStruct) {
    tsLines.push('      { binding: 0, resource: { buffer: uniformBuffer } },');
  }
  for (const entry of textureBindingEntries) {
    tsLines.push(`      { binding: ${entry.textureBinding}, resource: textureViews['${entry.param.textureName}'] },`);
    tsLines.push(`      { binding: ${entry.samplerBinding}, resource: samplers['${entry.param.textureName}'] },`);
  }
  tsLines.push('    ],');
  tsLines.push('  });');
  tsLines.push('');

  tsLines.push('  const rebuildBindGroup = () => {');
  tsLines.push('    bindGroup = device.createBindGroup({');
  tsLines.push('      layout: bindGroupLayout,');
  tsLines.push('      entries: [');
  if (uniformStruct) {
    tsLines.push('        { binding: 0, resource: { buffer: uniformBuffer } },');
  }
  for (const entry of textureBindingEntries) {
    tsLines.push(`        { binding: ${entry.textureBinding}, resource: textureViews['${entry.param.textureName}'] },`);
    tsLines.push(`        { binding: ${entry.samplerBinding}, resource: samplers['${entry.param.textureName}'] },`);
  }
  tsLines.push('      ],');
  tsLines.push('    });');
  tsLines.push('  };');
  tsLines.push('');

  tsLines.push(`  const handles: ${materialHandlesName} = {`);
  tsLines.push('    pipeline,');
  tsLines.push('    get bindGroup() { return bindGroup; },');
  tsLines.push('    setTexture: (name, texture) => {');
  tsLines.push('      textureViews[name] = texture;');
  tsLines.push('      rebuildBindGroup();');
  tsLines.push('    },');
  if (uniformStruct) {
    tsLines.push('    setUniforms: (updates) => {');
    tsLines.push('      currentUniforms = { ...currentUniforms, ...updates };');
    tsLines.push(`      pack${uniformStruct.name}(uniformFloats, uniformInts, uniformUints, 0, currentUniforms);`);
    tsLines.push('      device.queue.writeBuffer(uniformBuffer, 0, uniformData);');
    tsLines.push('    },');
  } else {
    tsLines.push('    setUniforms: () => {},');
  }
  tsLines.push('  };');
  tsLines.push('');
  tsLines.push('  return handles;');
  tsLines.push('}');
  tsLines.push('');

  const effectLines: string[] = [];
  effectLines.push(`export class ${effectClassName} extends CustomShaderEffect<${uniformInterfaceName}, ${inputsTypeName}> {`);
  effectLines.push(`  override effectName = '${shaderPrefix}';`);
  effectLines.push('');
  effectLines.push(`  constructor(device: GPUDevice, inputs: ${inputsTypeName}, width = 1280, height = 720, format: GPUTextureFormat = 'rgba16float', clearColor: GPUColor = { r: 0, g: 0, b: 0, a: 1 }) {`);
  effectLines.push('    super(device, inputs, {');
  effectLines.push(`      factory: (deviceRef, formatRef, options) => create${shaderPrefix}Material(deviceRef, formatRef, options),`);
  effectLines.push(`      textureInputKeys: ${inputTextureNamesArrayLiteral},`);
  effectLines.push(`      textureBindingKeys: ${shaderPrefix}TextureNames,`);
  effectLines.push(`      passTextureSources: ${shaderPrefix}PassTextureSources,`);
  effectLines.push(`      passCount: ${passCount},`);
  effectLines.push(`      primaryTextureKey: '${primaryTextureName}',`);
  effectLines.push('      width,');
  effectLines.push('      height,');
  effectLines.push('      format,');
  effectLines.push('      clearColor,');
  effectLines.push(`      uniformMeta: ${uniformMetaConstName},`);
  effectLines.push('    });');
  const fieldsWithDefaults = uniformFields.filter((field) => field.defaultExpression);
  if (fieldsWithDefaults.length > 0) {
    effectLines.push('    this.setUniforms({');
    fieldsWithDefaults.forEach((field) => {
      effectLines.push(`      ${field.name}: ${field.defaultExpression},`);
    });
    effectLines.push('    });');
  } else {
    const uniformNames = new Set(uniformFields.map((field) => field.name));
    const hasTransformDefaults = ['rotate', 'anchor', 'translate', 'scale'].every((name) => uniformNames.has(name));
    if (hasTransformDefaults) {
      effectLines.push('    this.setUniforms({ rotate: 0, anchor: [0.5, 0.5], translate: [0, 0], scale: [1, 1] });');
    }
  }
  effectLines.push('  }');

  if (uniformFields.length > 0) {
    const uniformParams = uniformFields
      .map((field) => {
        if (field.isArray && field.elementType) {
          const arrayMeta = ARRAY_ELEMENT_TYPE_MAP[field.elementType];
          return `${field.name}?: Dynamic<${arrayMeta.tsType}>`;
        }
        const meta = UNIFORM_TYPE_MAP[field.wgslType];
        return `${field.name}?: Dynamic<${meta.tsType}>`;
      })
      .join(', ');
    effectLines.push('');
    effectLines.push(`  override setUniforms(uniforms: { ${uniformParams} }): void {`);
    effectLines.push('    const record: ShaderUniforms = {};');
    uniformFields.forEach((field) => {
      effectLines.push(`    if (uniforms.${field.name} !== undefined) {`);
      effectLines.push(`      record['${field.name}'] = uniforms.${field.name};`);
      effectLines.push('    }');
    });
    effectLines.push('    super.setUniforms(record);');
    effectLines.push('  }');
  }

  effectLines.push('}');
  effectLines.push('');
  tsLines.push(...effectLines);

  const typesSource = `${tsLines.join('\n')}\n`;

  return {
    typesSource,
    shaderPrefix,
    effectClassName,
    uniformInterfaceName,
  };
}

export interface FragmentShaderErrorArtifactOptions {
  effectClassName: string;
  uniformInterfaceName: string;
  shaderPrefix: string;
  relativeSourcePath: string;
  errorMessage: string;
}

export function buildFragmentShaderErrorArtifactSource(options: FragmentShaderErrorArtifactOptions): string {
  const { effectClassName, uniformInterfaceName, shaderPrefix, relativeSourcePath, errorMessage } = options;
  const materialHandlesName = `${shaderPrefix}MaterialHandles`;
  const materialOptionsName = `${shaderPrefix}MaterialOptions`;
  const inputsTypeName = `${shaderPrefix}Inputs`;
  const textureNameType = `${shaderPrefix}TextureName`;
  const message = `Failed to generate shader for ${relativeSourcePath}: ${errorMessage}`;
  const lines: string[] = [];
  lines.push(HEADER_COMMENT);
  lines.push(`export const shaderGenerationErrorMessage = ${JSON.stringify(message)} as const;`);
  lines.push(`export type ${uniformInterfaceName} = never;`);
  lines.push(`export type ${textureNameType} = never;`);
  lines.push(`export interface ${inputsTypeName} {}`);
  lines.push(`export type ${materialHandlesName} = never;`);
  lines.push(`export interface ${materialOptionsName} { name?: string }`);
  lines.push(`export function create${shaderPrefix}Material(): never { throw new Error(shaderGenerationErrorMessage); }`);
  lines.push(`export class ${effectClassName} {`);
  lines.push('  constructor() {');
  lines.push('    throw new Error(shaderGenerationErrorMessage);');
  lines.push('  }');
  lines.push('}');
  lines.push('');
  return `${lines.join('\n')}\n`;
}
